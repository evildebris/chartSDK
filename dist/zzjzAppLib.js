(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["zzjzAppLib"] = factory();
	else
		root["zzjzAppLib"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/webpack/buildin/amd-define.js":
/*!***************************************!*\
  !*** (webpack)/buildin/amd-define.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function() {\n\tthrow new Error(\"define cannot be used indirect\");\n};\n\n\n//# sourceURL=webpack://zzjzAppLib/(webpack)/buildin/amd-define.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/amd-options.js":
/*!****************************************!*\
  !*** (webpack)/buildin/amd-options.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */\nmodule.exports = __webpack_amd_options__;\n\n/* WEBPACK VAR INJECTION */}.call(this, {}))\n\n//# sourceURL=webpack://zzjzAppLib/(webpack)/buildin/amd-options.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\r\n * @description appSDK 必须使用原生js封装和实现所有功能生成最小的sdk\r\n * @author cai.liao\r\n * @Date 2018.11.19\r\n * */\r\n\r\n\r\n// 模块引用\r\nvar zepto = __webpack_require__(/*! ./module/zepto */ \"./src/module/zepto.js\");\r\nvar appServer = __webpack_require__(/*! ./module/appServer */ \"./src/module/appServer.js\");\r\nvar comClass = __webpack_require__(/*! ./module/comClass */ \"./src/module/comClass.js\");\r\nvar ChartLib = __webpack_require__(/*! ./module/Chart */ \"./src/module/Chart.js\");\r\nvar zzjzAppLib = {};\r\nvar appMap = {};\r\nvar comMap = appServer.getComMap();\r\n\r\nzzjzAppLib.version = '0.0.0.1';\r\n//zzjzAppLib.initPromise = appServer.defer;\r\nwindow.angular = {\r\n    element:zepto\r\n};\r\n\r\nfunction Error(msg) {\r\n    this.message = msg;\r\n    console.error(msg);\r\n}\r\n/**\r\n * @class APP\r\n * @description 实现app类完成基础App相关图元操作和参数\r\n * */\r\nfunction App(app,dom) {\r\n    if(!app||!app.id){\r\n        throw new TypeError(\"App 初始化参数错误!\");\r\n    }\r\n    if(!app.chartMap){\r\n        console.warn(\"没有获取到chart错误数据\");\r\n    }\r\n    this.id = app.id;\r\n    this.name = app.name;\r\n    this.paramSetting = app.paramSetting;\r\n\r\n    // 解析初始化所需要初始化的算子\r\n    if(app.viewComMap) {\r\n        for(var comId in app.viewComMap) {\r\n            if(!comMap[comId]) {\r\n                comClass.initChartComRenderFuncObj(app.viewComMap[comId]);\r\n                comMap[comId] = app.viewComMap[comId];\r\n            }\r\n        }\r\n    }\r\n\r\n    //初始化app chart\r\n    this.chartList = ChartLib.createChartList(app.chartMap,dom,app.id);\r\n}\r\nApp.prototype = {\r\n    getAppById: function(id){\r\n        if(id && typeof id === 'string') {\r\n            return zzjzAppLib.apps[id];\r\n        }\r\n    },\r\n    reload: function (tables) {\r\n        if(tables && typeof tables === 'object') {\r\n            this.chartList && this.chartList.forEach(function (chart) {\r\n                chart.reload(tables);\r\n            });\r\n        }\r\n    }\r\n};\r\nzzjzAppLib.apps = {};\r\n/**\r\n * @method initApp\r\n * @description 根据传入appid从后台接口获取初始化app参数\r\n * @param appId {string} 对应app的id\r\n * @param dom {HTMLElement} 父集dom\r\n * */\r\nzzjzAppLib.initApp = function (appId,dom) {\r\n    var defer =new zepto.Deferred();\r\n    if(appId === undefined || appId === \"\" || appId === null){\r\n        defer.reject(new Error('initApp error: 请传入appId！'));\r\n    }else {\r\n        appServer.getAppDataById(appId).then(function (result) {\r\n            if(result.status === 'OK' && result.data){\r\n                zzjzAppLib.apps[appId] = new App(result.data,dom);\r\n                defer.resolve(zzjzAppLib.apps[appId]);\r\n            }else {\r\n                defer.reject(result);\r\n            }\r\n        },function (error) {\r\n            defer.reject(new Error(error.message));\r\n        });\r\n    }\r\n    return defer.promise();\r\n};\r\n/**\r\n * @method initAppByName\r\n * @description 根据传入appName和userName从后台接口获取初始化app参数\r\n * @param appId {string} 对应app的id\r\n * @param dom {HTMLElement} 父集dom\r\n * */\r\nzzjzAppLib.initAppByName = function (appName,userName,dom) {\r\n    var defer =new zepto.Deferred();\r\n    if(appName === undefined || appName === \"\" || appName === null){\r\n        defer.reject(new Error('initApp error: appName is empty！'));\r\n    }else if(userName === undefined || userName === \"\" || userName === null){\r\n        defer.reject(new Error('initApp error: userName is empty！'));\r\n    }else {\r\n        appServer.getAppByAppName(appName,userName).then(function (result) {\r\n            if(result.status === 'OK' && result.data){\r\n                zzjzAppLib.apps[appId] = new App(result.data,dom);\r\n                defer.resolve(zzjzAppLib.apps[appId]);\r\n            }else {\r\n                defer.reject(result);\r\n            }\r\n        },function (error) {\r\n            defer.reject(new Error(error.message));\r\n        });\r\n    }\r\n    return defer.promise();\r\n};\r\n/**\r\n * @method runApp\r\n * @description 执行app返回对应的table数据和相应的需要刷新的chart\r\n * @param appId {string} 对应app的id\r\n * */\r\nzzjzAppLib.runApp = function(appId,paramSetting){\r\n    var defer =new zepto.Deferred();\r\n    if(appId === undefined || appId === \"\" || appId === null){\r\n        defer.reject(new Error('initApp error: 请传入appId！'));\r\n    }else {\r\n        appServer.runApp(appId,paramSetting).then(function (result) {\r\n            if(result.status === 'OK' && result.data){\r\n                ChartLib.refreshChart(result.data);\r\n                defer.resolve(result.data);\r\n            }else {\r\n                defer.reject(result);\r\n            }\r\n        },function (error) {\r\n            defer.reject(new Error(error.message));\r\n        });\r\n    }\r\n    return defer.promise();\r\n};\r\n\r\n\r\nmodule.exports = zzjzAppLib;\n\n//# sourceURL=webpack://zzjzAppLib/./src/index.js?");

/***/ }),

/***/ "./src/module/Chart.js":
/*!*****************************!*\
  !*** ./src/module/Chart.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;/**\r\n * @author cai.liao\r\n * 实现Chart类和相关服务功能\r\n * */\r\n\r\nvar appServer = __webpack_require__(/*! ./appServer */ \"./src/module/appServer.js\");\r\nvar chartContainerSer = __webpack_require__(/*! ./chartContainer */ \"./src/module/chartContainer.js\");\r\nvar $ = __webpack_require__(/*! ./zepto */ \"./src/module/zepto.js\");\r\nvar allChartMap = {};\r\nvar linkCahrtMap = {};\r\nvar linkedCahrtMap = {};\r\nfunction Chart(chartData,appId) {\r\n    if(!chartData&&!chartData.chartId){\r\n       throw new TypeError('图元信息初始化参数错误！');\r\n    }\r\n    this.initArgs = chartData;\r\n    this.selectedChart = this.initArgs.paramSetting.value;\r\n    this.chartId = chartData.chartId;\r\n    this._appId = appId;\r\n    if(this.initArgs.container && this.initArgs.container instanceof HTMLElement){\r\n        this.initChart(this.initArgs.container);\r\n    }\r\n}\r\nChart.prototype = {\r\n    initChart: function (dom,chartDatas) {\r\n        var _this = this;\r\n        if(!dom || !(dom instanceof HTMLElement)){\r\n            throw new TypeError('initChart初始化参数错误！');\r\n        }\r\n        _this.resultData = chartDatas || {};\r\n        _this.initArgs.container = dom;\r\n        if(!_this.initArgs.parentLinkChartId){\r\n            _this.render();\r\n        }\r\n    },\r\n    render: function () {\r\n        if(!this.initArgs.container){\r\n            return;\r\n        }\r\n        var _this = this;\r\n        var viewComArr = appServer.getCaseCharts(_this.initArgs.caseVal);\r\n        if(viewComArr && viewComArr.length){\r\n            viewComArr.forEach(function (viewCom) {\r\n                if(_this.selectedChart === viewCom.id){\r\n                    if(viewCom.plugins){\r\n                        try {\r\n                            chartContainerSer.ctnInit(viewCom.plugins).then(function () {\r\n\r\n                            });\r\n                        }catch (e){\r\n                            console.log('容器加载error: %s',e);\r\n                        }\r\n                    }\r\n                    if(_this.instance){// 关闭回调\r\n                        viewCom.template.renderFuncObj.close(_this.instance);\r\n                        _this.instance = null;\r\n                    }\r\n                    // 渲染图元\r\n                    _this.instance = viewCom.template.renderFuncObj.render(_this.instance, _this.initArgs, _this.initArgs.theme, _this.resultData);\r\n                }\r\n            })\r\n        }\r\n    },\r\n    resize: function () {\r\n        if(this.instance){\r\n            this.instance.resize && this.instance.resize();\r\n        }\r\n    },\r\n    reload: function (chartDatas) {\r\n        if(chartDatas && typeof chartDatas === 'object'){\r\n            this.resultData = chartDatas;\r\n            this.render();\r\n        }\r\n    },\r\n    /**\r\n     * @method doLinkage\r\n     * @description 触发联动，但没有配置联动或者未选择联动时该方法会报错\r\n     * */\r\n    doLinkage: function () {\r\n        if(!linkedCahrtMap[this.chartId]) {\r\n            throw new TypeError('该图没有设置联动，请先设置对应联动！');\r\n        }\r\n        if(!this.initArgs.selectedData||!this.initArgs.selectedData.tables){\r\n            throw new TypeError('请先在图上选择联动数据！');\r\n        }\r\n        var linkageId = this.initArgs.viewResultId + '_' + this.initArgs.layoutId;\r\n        var _this = this;\r\n        appServer.runLinkage(this._appId,linkageId,this.initArgs.selectedData).then(function (result) {\r\n            if(result.status === 'OK' && result.data){\r\n                var linkedChart = allChartMap[linkedCahrtMap[_this.chartId]];\r\n                if(linkedChart){\r\n                    _this.resultData = result.data;\r\n                    _this.selectedChart = linkedChart.initArgs.paramSetting.value;\r\n                    _this.chartId = linkedChart.chartId;\r\n                    $.extend(_this.initArgs,linkedChart.initArgs);\r\n                    _this.render();\r\n                }\r\n            }else {\r\n                throw new TypeError(result.message);\r\n            }\r\n        });\r\n    }\r\n};\r\nfunction createChartList(chartMap,parentDom,appId) {\r\n    var chartList = [],hasParent;\r\n    if(parentDom && parentDom instanceof HTMLElement){\r\n        $(parentDom).addClass(\"chart_window\");\r\n        hasParent = true;\r\n    }\r\n    for(var chartId in chartMap){\r\n        if(hasParent && !chartMap[chartId].parentLinkChartId){ // 将所有\r\n            var div = $(document.createElement('div'));\r\n            var div2 = $(document.createElement('div'));\r\n            div.addClass('chart_box');\r\n            div2.addClass('chart_body');\r\n            div.append(div2);\r\n            $(parentDom).append(div);\r\n            chartMap[chartId].container = div2[0];\r\n        }\r\n        allChartMap[chartId] = new Chart(chartMap[chartId],appId);\r\n        if(!allChartMap[chartId].initArgs.parentLinkChartId) { //是否是联动图元\r\n            chartList.push(allChartMap[chartId]);\r\n        }else {\r\n            linkCahrtMap[chartId] = allChartMap[chartId].initArgs.parentLinkChartId;\r\n            linkedCahrtMap[allChartMap[chartId].initArgs.parentLinkChartId] = chartId;\r\n        }\r\n    }\r\n    return chartList;\r\n}\r\nfunction refreshChart(nodeDataList) {\r\n    nodeDataList.forEach(function (nodeData) {\r\n        if($.isArray(nodeData.chartList)){\r\n            nodeData.chartList.forEach(function (chartId) {\r\n                var chart =allChartMap[chartId];\r\n                chart.initArgs.viewResultId = nodeData.viewResultId;\r\n                if(chart && !chart.initArgs.parentLinkChartId){\r\n                    chart.reload(nodeData.result);\r\n                }\r\n            })\r\n        }\r\n    })\r\n}\r\n$(window).on('resize',function () {\r\n    for(var chartId in allChartMap){\r\n        var chart =allChartMap[chartId];\r\n        if(chart && chart.instance){\r\n            chart.resize();\r\n        }\r\n    }\r\n});\r\nmodule.exports = {\r\n    Chart: Chart,\r\n    createChartList: createChartList,\r\n    refreshChart: refreshChart\r\n};\r\n\r\n/**********************************************chart全局方法*************************************************/\r\n/**\r\n * Created by tanglvshuang on 2017/4/25 0025. dom,数据,数据,echats实例,作用域\r\n */\r\nfunction createBrush(params) {\r\n    var objBrush = new Object();\r\n    var isCrosshair=false;\r\n    objBrush.dom = params.dom;\r\n    objBrush.theme=params.theme;\r\n    objBrush.params = params;\r\n    objBrush.chart = params.charts;\r\n    objBrush.dataset = params.dataset;\r\n    objBrush.brushF = params.brushF;\r\n    objBrush.isInit = true;\r\n    objBrush.initArgs = params.initArgs;\r\n    objBrush.iPrevX = 0, //起点X\r\n        objBrush.iPrevY = 0, //起点Y\r\n        objBrush.upperX = 0;\r\n    objBrush.upperY = 0;\r\n    objBrush.color = 'rgba(0, 0, 0, 0.1);';\r\n    objBrush.w = 0; //宽\r\n    objBrush.h = 0; //高\r\n    objBrush.x = 0;\r\n    objBrush.y = 0;\r\n    objBrush.p = null;\r\n    objBrush.isInit = true;\r\n    var hasclick=false;\r\n    objBrush.draw = function (x, y, w, h, color) {\r\n        this.x = x\r\n        this.y = y\r\n        this.w = w\r\n        this.h = h\r\n        if (this.w > 0 && this.h > 0 && objBrush.theme==\"customed\") {\r\n            objBrush.chart.setOption({\r\n                graphic: {\r\n                    type: 'rect',\r\n                    id: \"rect\",\r\n                    zlevel: 10000,\r\n                    draggable: true,\r\n                    cursor: 'move',\r\n                    bounding: 'all',\r\n                    shape: {\r\n                        x: this.x,\r\n                        y: this.y,\r\n                        width: this.w,\r\n                        height: this.h,\r\n                        lineWidth: 50,\r\n                    },\r\n                    style: {\r\n                        fill: 'rgba(204,204,204,0.5)',\r\n                        stroke: 'rgba(234,234,234,0.5)',\r\n                        lineWidth: 2,\r\n                    },\r\n                    onmouseover: function (e) {\r\n                        var canvas = e.event.currentTarget.querySelectorAll('canvas');\r\n                        angular.forEach(canvas, function (canva) {\r\n                            canva.style.cursor = \"move\";\r\n                        });\r\n                    },\r\n                    onmouseout: function (e) {\r\n                        var canvas = e.event.currentTarget.querySelectorAll('canvas');\r\n                        angular.forEach(canvas, function (canva) {\r\n                            canva.style.cursor = \"pointer\";\r\n                            objBrush.isInit = true; //移除激活\r\n                            objBrush.iPrevX = 0; //鼠标点击 first\r\n                            objBrush.p = null;\r\n                        });\r\n                    },\r\n                    onclick:\r\n                    //ondragend:\r\n                        function (e) {\r\n                            var transform = this.transform;\r\n                            //var moveX=transform[4];\r\n                            //var moveY=transform[5];//拖拽之后的左上角X,Y 也是最低点\r\n                            var startX = e.target.shape.x; //起始x\r\n                            var startY = e.target.shape.y; //起始y\r\n                            var position = e.target.position; //平移坐标\r\n                            var moveX = startX + position[0]; //移动之后的最小X\r\n                            var moveY = startY + position[1]; //移动之后的最小Y\r\n                            var maxX = moveX + e.target.shape.width;\r\n                            var maxY = moveY + e.target.shape.height;\r\n                            objBrush.initArgs.range = [\r\n                                [maxX, maxY],\r\n                                [moveX, moveY]\r\n                            ];\r\n                            objBrush.brushF(objBrush.initArgs, objBrush.chart, objBrush.dataset);\r\n                            // objBrush.brushSelectedForceFunction(objBrush.params,objBrush.param,objBrush.chart,moveX,moveY,maxX,maxY);\r\n                        }\r\n                }\r\n            });\r\n        }else {\r\n            objBrush.chart.setOption({\r\n                graphic: {\r\n                    type: 'rect',\r\n                    id: \"rect\",\r\n                    zlevel: 10000,\r\n                    draggable: true,\r\n                    cursor: 'move',\r\n                    bounding: 'all',\r\n                    shape: {\r\n                        x: this.x,\r\n                        y: this.y,\r\n                        width: this.w,\r\n                        height: this.h,\r\n                        lineWidth: 50,\r\n                    },\r\n                    style: {\r\n                        fill: 'rgba(0,0,0,0.2)',\r\n                        stroke: 'rgba(0,0,0,0.5)',\r\n                        lineWidth: 2,\r\n                    },\r\n                    onmouseover: function (e) {\r\n                        var canvas = e.event.currentTarget.querySelectorAll('canvas');\r\n                        angular.forEach(canvas, function (canva) {\r\n                            canva.style.cursor = \"move\";\r\n                        });\r\n                    },\r\n                    onmouseout: function (e) {\r\n                        var canvas = e.event.currentTarget.querySelectorAll('canvas');\r\n                        angular.forEach(canvas, function (canva) {\r\n                            canva.style.cursor = \"pointer\";\r\n                            objBrush.isInit = true; //移除激活\r\n                            objBrush.iPrevX = 0; //鼠标点击 first\r\n                            objBrush.p = null;\r\n                        });\r\n                    },\r\n                    onclick:\r\n                    //ondragend:\r\n                        function (e) {\r\n                            var transform = this.transform;\r\n                            //var moveX=transform[4];\r\n                            //var moveY=transform[5];//拖拽之后的左上角X,Y 也是最低点\r\n                            var startX = e.target.shape.x; //起始x\r\n                            var startY = e.target.shape.y; //起始y\r\n                            var position = e.target.position; //平移坐标\r\n                            var moveX = startX + position[0]; //移动之后的最小X\r\n                            var moveY = startY + position[1]; //移动之后的最小Y\r\n                            var maxX = moveX + e.target.shape.width;\r\n                            var maxY = moveY + e.target.shape.height;\r\n                            objBrush.initArgs.range = [\r\n                                [maxX, maxY],\r\n                                [moveX, moveY]\r\n                            ];\r\n                            objBrush.brushF(objBrush.initArgs, objBrush.chart, objBrush.dataset);\r\n                            // objBrush.brushSelectedForceFunction(objBrush.params,objBrush.param,objBrush.chart,moveX,moveY,maxX,maxY);\r\n                        }\r\n                }\r\n            });\r\n        }\r\n        //清空初始化\r\n        var canvas = objBrush.dom.querySelectorAll('canvas');\r\n        angular.forEach(canvas, function (canva) {\r\n            canva.style.cursor = \"crosshair\";\r\n            objBrush.isInit = true; //移除激活\r\n            objBrush.iPrevX = 0; //鼠标点击 first\r\n            objBrush.p = null;\r\n        });\r\n    }\r\n    objBrush.draw1 = function (x, y, w, h, color) {\r\n        this.x = x\r\n        this.y = y\r\n        this.w = w\r\n        this.h = h\r\n        if (this.w > 0 && this.h > 0 && objBrush.theme==\"customed\") {\r\n            objBrush.chart.setOption({\r\n                graphic: {\r\n                    type: 'rect',\r\n                    id: \"rect\",\r\n                    zlevel: 10000,\r\n                    draggable: true,\r\n                    cursor: 'move',\r\n                    bounding: 'all',\r\n                    shape: {\r\n                        x: this.x,\r\n                        y: this.y,\r\n                        width: this.w,\r\n                        height: this.h,\r\n                        lineWidth: 50,\r\n                    },\r\n                    style: {\r\n                        fill: 'rgba(204,204,204,0.5)',\r\n                        stroke: 'rgba(234,234,234,0.5)',\r\n                        lineWidth: 2,\r\n                    },\r\n                }\r\n            });\r\n        }else {\r\n            objBrush.chart.setOption({\r\n                graphic: {\r\n                    type: 'rect',\r\n                    id: \"rect\",\r\n                    zlevel: 10000,\r\n                    draggable: true,\r\n                    cursor: 'move',\r\n                    bounding: 'all',\r\n                    shape: {\r\n                        x: this.x,\r\n                        y: this.y,\r\n                        width: this.w,\r\n                        height: this.h,\r\n                        lineWidth: 50,\r\n                    },\r\n                    style: {\r\n                        fill: 'rgba(0,0,0,0.2)',\r\n                        stroke: 'rgba(0,0,0,0.5)',\r\n                        lineWidth: 2,\r\n                    },\r\n                }\r\n            });\r\n        }\r\n    }\r\n    objBrush.OnMouseMove = function (evt) {\r\n        // if (this.p && this.p.isDown) {\r\n        //     var X = evt.layerX - objBrush.p.w / 2;\r\n        //     var Y = evt.layerY - objBrush.p.h / 2;\r\n        // }\r\n        // if (hasclick){\r\n        var X = evt.offsetX;\r\n        var Y = evt.offsetY;\r\n        var width = Math.floor(X - this.iPrevX);\r\n        var height = Math.floor(Y - this.iPrevY);\r\n        this.w = Math.abs(width);\r\n        this.h = Math.abs(height);\r\n        // var canvas = this.dom.querySelectorAll('canvas');\r\n        // // var isCrosshair = false; //是否开启鼠标画矩形\r\n        // angular.forEach(canvas, function (canva) {\r\n        //     if (canva.style.cursor == \"crosshair\") {\r\n        //         isCrosshair = true;\r\n        //     }\r\n        // });\r\n        if (hasclick) {\r\n            objBrush.p=null;\r\n            this.p = new this.draw1(this.iPrevX, this.iPrevY, this.w, this.h, this.color);\r\n            this.upperX = this.iPrevX; //上一次画的开始节点\r\n            this.upperY = this.iPrevY;\r\n            evt.stopPropagation(); //阻止事件冒泡\r\n        } else {\r\n            evt.preventDefault(); //事件冒泡\r\n        }\r\n        // }\r\n    }\r\n    objBrush.OnMouseDown = function (evt) {\r\n\r\n        var X = evt.offsetX;\r\n        var Y = evt.offsetY;\r\n\r\n        if ((this.isInit && this.iPrevX == 0)) {\r\n            this.iPrevX = X;\r\n            this.iPrevY = Y;\r\n        }\r\n        var canvas = this.dom.querySelectorAll('canvas');\r\n        var isCrosshair = false; //是否开启鼠标画矩形\r\n        angular.forEach(canvas, function (canva) {\r\n            if (canva.style.cursor == \"crosshair\") {\r\n                isCrosshair = true;\r\n                hasclick=true;\r\n            }\r\n        });\r\n        if (isCrosshair) {\r\n            evt.stopPropagation(); //阻止事件冒泡\r\n        } else {\r\n            evt.preventDefault(); //事件冒泡\r\n        }\r\n    }\r\n    //力引导图刷选数据\r\n    objBrush.brushSelectedForceFunction = function () {\r\n\r\n    }\r\n    objBrush.OnMouseUp = function (evt) {\r\n        var X = evt.offsetX;\r\n        var Y = evt.offsetY;\r\n        var width = Math.floor(X - this.iPrevX);\r\n        var height = Math.floor(Y - this.iPrevY);\r\n        this.w = Math.abs(width);\r\n        this.h = Math.abs(height);\r\n        var canvas = this.dom.querySelectorAll('canvas');\r\n        // var isCrosshair = false; //是否开启鼠标画矩形\r\n        angular.forEach(canvas, function (canva) {\r\n            if (canva.style.cursor == \"crosshair\") {\r\n                isCrosshair = true;\r\n            }\r\n        });\r\n        if (isCrosshair) {\r\n            objBrush.p=null;\r\n            this.p = new this.draw(this.iPrevX, this.iPrevY, this.w, this.h, this.color);\r\n            this.upperX = this.iPrevX; //上一次画的开始节点\r\n            this.upperY = this.iPrevY;\r\n            angular.forEach(canvas, function (canva) {\r\n                if (canva.style.cursor == \"crosshair\") {\r\n                    canva.style.cursor = \"pointer\"\r\n                }\r\n            });\r\n            evt.stopPropagation(); //阻止事件冒泡\r\n        } else {\r\n            evt.preventDefault(); //事件冒泡\r\n        }\r\n        hasclick=false;\r\n        isCrosshair=false;\r\n        // this.dom.removeEventListener(\"mousemove\",this.OnMouseMove.bind(this),true);\r\n        //}\r\n    }\r\n    objBrush.event = function () {\r\n        this.dom.addEventListener(\"mousedown\", this.OnMouseDown.bind(this), true);\r\n        this.dom.addEventListener(\"mousemove\",this.OnMouseMove.bind(this),true);\r\n        this.dom.addEventListener(\"mouseup\", this.OnMouseUp.bind(this), true);\r\n    }\r\n    objBrush.event();\r\n    return objBrush;\r\n}\r\n/*\r\n * editor : taoyahui\r\n * date : 2018.01.11 09:30:10\r\n * */\r\n//随机整数\r\nfunction RandomNumBetween(Min, Max) {\r\n    var Range = Max - Min + 1;\r\n    var Rand = Math.random();\r\n    var num = Min + Math.floor(Rand * Range); //取整\r\n    return num;\r\n}\r\n//取索引\r\nfunction getIndex(name, tableName, dataset) {\r\n    var dataIndex;\r\n    for (var i = 0; i < dataset[tableName].schema.length; i++) {\r\n        if (dataset[tableName].schema[i].name == name) {\r\n            dataIndex = dataset[tableName].schema[i].index;\r\n            break;\r\n        }\r\n    }\r\n    return dataIndex;\r\n}\r\n//判断拖入设置的数据列的数据格式是不是和需求复合\r\nfunction checkDataType(setArray, tableName, dataset, targetType, call) {\r\n    for (var i = 0, setArrayLength = setArray.length; i < setArrayLength; i++) {\r\n        var currentSetIndex = getIndex(setArray[i].name, tableName, dataset);\r\n        var helpArray = [];\r\n        for (var j = 0, tableLength = dataset[tableName].table.length; j < tableLength; j++) {\r\n            var randomData = RandomNumBetween(0, dataset[tableName].table.length - 1);\r\n            while (helpArray.indexOf(randomData) > -1) {\r\n                randomData = RandomNumBetween(0, dataset[tableName].table.length - 1);\r\n            }\r\n            helpArray.push(randomData);\r\n            if (dataset[tableName].table[randomData][currentSetIndex] != undefined && dataset[tableName].table[randomData][currentSetIndex] != \"null\") {\r\n                if (typeof dataset[tableName].table[randomData][currentSetIndex] == targetType) {\r\n                    break;\r\n                } else {\r\n                    if (call) {\r\n                        call(setArray[i].name);\r\n                    }\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}\r\n/*\r\n * editor : xiafangliang\r\n * date : 2018.01.19 09:30:10\r\n * */\r\nfunction checkTypeTy(initArgs, dataset, charts, arrListName, targetType, checkText) {\r\n    var tableName = initArgs.paramSetting.tableName;\r\n    for (var i = 0; i < arrListName.length; i++) {\r\n        var ele = arrListName[i];\r\n        if ((ele != undefined) && (ele instanceof Array) && (ele.length > 0)) {\r\n            var flag = checkDataType(ele, tableName, dataset, targetType, function (item) {\r\n                (checkText.innerHTML == \"\") && (checkText.innerHTML = item + \"与所需数据类型不匹配,未生效,请检查!\");\r\n            });\r\n        }\r\n    }\r\n};\r\n\r\nfunction promptExceptionData(initArgs, dataset, charts, arrListIdnex, dataType, checkText) {\r\n    var p = initArgs.paramSetting;\r\n    var tableName = p.tableName;\r\n    if (arrListIdnex.companionLocusTableName) tableName = p.companionLocusTableName;\r\n    var data = dataset[tableName].table;\r\n    var tips = function (checkText) {\r\n        if (checkText.innerHTML == \"\") {\r\n            checkText.innerHTML = \"有异常数据,已处理,请检查!\";\r\n            charts.timer = setTimeout(function () {\r\n                $(checkText).remove();\r\n            }, 5000);\r\n        }\r\n    }\r\n    if (dataType == \"number\") {\r\n        for (var i = 0; i < arrListIdnex.length; i++) {\r\n            var listIndex = arrListIdnex[i][0];\r\n            var type = arrListIdnex[i][1];\r\n            if (listIndex != undefined) {\r\n                for (var j = 0; j < data.length; j++) {\r\n                    var ele = data[j];\r\n                    switch (type) {\r\n                        case \"longitude\":\r\n                            if (ele[listIndex] == null || ele[listIndex] > 180 || ele[listIndex] < -180) {\r\n                                tips(checkText);\r\n                            };\r\n                            break;\r\n                        case \"latitude\":\r\n                            if (ele[listIndex] == null || ele[listIndex] > 90 || ele[listIndex] < -90) {\r\n                                tips(checkText);\r\n                            };\r\n                            break;\r\n                        case \"number\":\r\n                            if (ele[listIndex] == null) {\r\n                                tips(checkText);\r\n                            };\r\n                            break;\r\n                    }\r\n                }\r\n            } else {\r\n                return;\r\n            }\r\n        }\r\n    } else if (dataType == \"string\") {\r\n        var reg = new RegExp(/^\\[.*\\]$/);\r\n        for (var i = 0; i < arrListIdnex.length; i++) {\r\n            var listIndex = arrListIdnex[i][0];\r\n            var type = arrListIdnex[i][1];\r\n            if (listIndex != undefined) {\r\n                for (var j = 0; j < data.length; j++) {\r\n                    var el;\r\n                    if (reg.test(data[j][listIndex])) {\r\n                        el = JSON.parse(data[j][listIndex]);\r\n                    } else {\r\n                        tips(checkText);\r\n                    };\r\n                    switch (type) {\r\n                        case \"track2D\":\r\n                            if (el.length > 1) {\r\n                                for (var k = 0; k < el.length; k++) {\r\n                                    var et = el[k];\r\n                                    if ((typeof et[0] != \"number\") || (typeof et[1] != \"number\")) {\r\n                                        tips(checkText);\r\n                                    } else if ((typeof et[0] == \"number\") && (typeof et[1] == \"number\")) {\r\n                                        if (et[0] > 180 || et[0] < -180 || et[1] > 90 || et[1] < -90) {\r\n                                            tips(checkText);\r\n                                        }\r\n                                    }\r\n                                }\r\n                            } else {\r\n                                tips(checkText);\r\n                            }\r\n                            break;\r\n                        case \"track3D\":\r\n                            if (el.length > 1) {\r\n                                for (var k = 0; k < el.length; k++) {\r\n                                    var et = el[k];\r\n                                    if ((typeof et[0] != \"number\") || (typeof et[1] != \"number\")) {\r\n                                        tips(checkText);\r\n                                    } else if ((typeof et[0] == \"number\") && (typeof et[1] == \"number\")) {\r\n                                        if (et[0] > 180 || et[0] < -180 || et[1] > 90 || et[1] < -90) {\r\n                                            tips(checkText);\r\n                                        }\r\n                                    }\r\n                                    if (et[2] != undefined) {\r\n                                        if (typeof et[2] != \"number\") {\r\n                                            tips(checkText);\r\n                                        }\r\n                                    }\r\n                                }\r\n                            } else {\r\n                                tips(checkText);\r\n                            }\r\n                            break;\r\n                    }\r\n                }\r\n            } else {\r\n                return;\r\n            }\r\n        }\r\n    } else {\r\n        return;\r\n    }\r\n};\r\n/* end : 2018.01.11 09:30:10 */\r\n\r\nfunction DrawBrush(canvas,ctx,params,param,chart,scope){\r\n    this._init_(canvas,ctx,params,param,chart,scope);\r\n}\r\nDrawBrush.prototype ={\r\n    constructor:DrawBrush,\r\n    scope:null,\r\n    params:null,\r\n    param:null,\r\n    chart:null,\r\n    _init_:function(canvas,ctx,params,param,chart,scope){\r\n        this.ctx=ctx;\r\n        this.scope=scope;\r\n        this.params=params;\r\n        this.param=param;\r\n        this.chart=chart,\r\n\r\n            /* DrawBrush.prototype.scope=scope;\r\n             DrawBrush.prototype.params=params;\r\n             DrawBrush.prototype.param=param;\r\n             DrawBrush.prototype.chart=chart;*/\r\n            this.canvas=canvas;\r\n        this.canvas.style.cursor=\"crosshair\"; //zIndex=888;\r\n        //  this.canvas.style=\"zIndex:10000\";\r\n        this.event(canvas);\r\n        this.draw.prototype=this;\r\n        this.setForce.prototype=this;\r\n        this.brushSelectedForceFunction.prototype=this;\r\n        this.isInit=true;\r\n        this.iPrevX=0,//起点X\r\n            this.iPrevY=0,//起点Y\r\n            this.upperX=0;\r\n        this.upperY=0;\r\n        this.color='rgba(0, 0, 0, 0.1);';\r\n        this.w=0;//宽\r\n        this.h=0;//高\r\n    },\r\n    draw:function(x,y,w,h,color){\r\n        //this.ctx.clearRect(this.x-1,this.y-1,this.w+2,this.h+2);\r\n        //this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height);\r\n        //this.ctx.globalAlpha = 0.8;\r\n        this.x=x\r\n        this.y=y\r\n        this.w=w\r\n        this.h=h\r\n        if(this.w>0&&this.h>0){\r\n            this.chart.setOption({\r\n                graphic: {\r\n                    type: 'rect',\r\n                    id: 'rect',\r\n                    zlevel:10000,\r\n                    draggable:true,\r\n                    cursor:'move',\r\n                    bounding:'all',\r\n                    shape: {\r\n                        x: this.x,\r\n                        y: this.y,\r\n                        width:this.w,\r\n                        height:this.h,\r\n                        lineWidth:12,\r\n                    },\r\n                    style:{\r\n                        fill:'rgba(0,0,0,0.2)',\r\n                    },\r\n                    ondragend:function(e){\r\n                        var transform =this.transform;\r\n                        //var moveX=transform[4];\r\n                        //var moveY=transform[5];//拖拽之后的左上角X,Y 也是最低点\r\n                        var startX= e.target.shape.x;//起始x\r\n                        var startY= e.target.shape.y;//起始y\r\n                        var position= e.target.position; //平移坐标\r\n                        var moveX=startX+position[0];//移动之后的最小X\r\n                        var moveY=startY+position[1];//移动之后的最小Y\r\n                        var maxX=moveX+e.target.shape.width;\r\n                        var maxY=moveY+e.target.shape.height;\r\n                        //this.brushSelectedForceFunction(this.params,this.param,this.chart,moveX,moveY,maxX,maxY);\r\n                    }\r\n\r\n                }\r\n            });\r\n        }\r\n        //this.color=color\r\n        //this.ctx.fillStyle = \"rgba(0,0,0,0.2)\";\r\n        //this.ctx.strokeStyle=this.color\r\n        //this.upperX=this.x;//上一次画的开始节点\r\n        //this.upperY=this.y;\r\n        //this.ctx.strokeRect(this.x,this.y,this.w,this.h);\r\n\r\n    },\r\n    OnMouseMove:function(evt){\r\n        if(this.p&&this.p.isDown){\r\n            var X=evt.layerX-this.p.w/2;\r\n            var Y=evt.layerY-this.p.h/2;\r\n            //this.p.draw(X,Y,this.w,this.h,this.color);\r\n        }\r\n    },\r\n    OnMouseDown:function(evt){\r\n        var X=evt.layerX;\r\n        var Y=evt.layerY;\r\n        if(this.p){\r\n            if(X<this.p.x+this.p.w&&X>this.p.x)\r\n            {\r\n                if(Y<this.p.y+this.p.h&&Y>this.p.y){\r\n                    this.p.isDown=true;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                this.p.isDown=false;\r\n            }\r\n        }\r\n        if((this.isInit&&this.iPrevX==0)){\r\n            this.iPrevX=X;\r\n            this.iPrevY=Y;\r\n        }else{\r\n            /**if(!this.ctx.isPointInPath(X,Y)){//初始化||判断是否在矩形内,不在则清空上一次的画的内容,重新画矩形\r\n\t\t\t\t\t  this.upperX=this.iPrevX;\r\n\t\t\t\t\t  this.upperY=this.iPrevY;\r\n\t\t\t\t\t  this.iPrevX=X;\r\n\t\t\t\t\t  this.iPrevY=Y;\r\n\r\n\t\t\t\t }**/\r\n        }\r\n    },\r\n//力引导图刷选数据\r\n    brushSelectedForceFunction:function(params,param,chart,_minX,_minY,_maxX,_maxY){\r\n        console.log(this);\r\n        Array.prototype.unique = function (isStrict) {\r\n            if (this.length < 2)\r\n                return [this[0]] || false;\r\n            var tempObj = {}, newArr = [];\r\n            for (var i = 0; i < this.length; i++) {\r\n                var v = this[i];\r\n                var condition = isStrict ? (typeof tempObj[v] != typeof v) : false;\r\n                if ((typeof tempObj[v] == \"undefined\") || condition) {\r\n                    tempObj[v] = v;\r\n                    newArr.push(v);\r\n                }\r\n            }\r\n            return newArr;\r\n        }\r\n        if(params.tableData[\"inputTableName1\"].rows.length!=0) {\r\n            String.prototype.startWith = function (str) {\r\n                if (str == null || str == \"\" || this.length == 0 || str.length > this.length)\r\n                    return false;\r\n                if (this.substr(0, str.length) == str)\r\n                    return true;\r\n                else\r\n                    return false;\r\n                return true;\r\n            }\r\n            //获取数据index\r\n            function getIndexByName(list, name) {\r\n                for (var i = 0; i < list.length; i++) {\r\n                    if (list[i].name.startWith(name)) {\r\n                        return list[i].index;\r\n                    }\r\n                }\r\n            };\r\n            String.prototype.trim = function () {\r\n\r\n                // 用正则表达式将前后空格\r\n                // 用空字符串替代。\r\n                return this.replace(/(^\\s*)|(\\s*$)/g, \"\");\r\n            }\r\n            var inputTableName = params.paramModel.inputTableName1.trim();\r\n            //inputTableName 关系节点\r\n            var inputColumnNames = params.tableData[\"inputTableName1\"].columnNames;\r\n            var subType = params.paramModel.subType;\r\n            var inputTableRows = params.tableData[\"inputTableName1\"].rows;\r\n            var nodeID = (param.paramModel.nodesid).split(\",\");//节点ID\r\n            var nodeIDIndex = getIndexByName(inputColumnNames, nodeID[0]);//数据ID\r\n\r\n            var inputList = [];\r\n            for (var i = 0; i < inputColumnNames.length; i++) {\r\n                var index = inputColumnNames[i].index;\r\n                var name = inputColumnNames[i].name.replace(/\\(.+\\)/g, \"\");\r\n                var obj = new Object();\r\n                obj.id = index;\r\n                obj.name = name;\r\n                inputList.push(obj);\r\n            }\r\n            ;\r\n\r\n\r\n            var inputDragParam = {\r\n                all: false,\r\n                type: subType,\r\n                sourceData: null,\r\n                inputTableName: inputTableName,\r\n                rows: null,\r\n                lists: inputList,\r\n                params: []\r\n            };\r\n            /////////////////////////////关系表\r\n            //是否包含关系表\r\n            var isHasRelation = false;\r\n            var inputListRelation = [];\r\n            var inputTableNameRelation = null;\r\n            var inputColumnNamesRelation = null;\r\n            var inputTableRowsRelation = null;\r\n            var linkssource = null;\r\n            var linkssourceIndex = null;\r\n            var linkstarget = null;\r\n            var linkstargetIndex = null;\r\n            var inputDragParamRelation = null;\r\n            if (params.tableData[\"inputTableName2\"]) {\r\n                isHasRelation = true;\r\n            }\r\n            if (isHasRelation) {\r\n                inputTableNameRelation = params.paramModel.inputTableName2.trim();\r\n                inputColumnNamesRelation = params.tableData[\"inputTableName2\"].columnNames;\r\n                inputTableRowsRelation = params.tableData[\"inputTableName2\"].rows;\r\n\r\n                linkssource = (param.paramModel.linkssource).split(\",\");//起始节点 ID\r\n                linkssourceIndex = getIndexByName(inputColumnNamesRelation, linkssource[0]);//起始节点index\r\n\r\n                linkstarget = (param.paramModel.linkstarget).split(\",\");//起始节点 ID\r\n                linkstargetIndex = getIndexByName(inputColumnNamesRelation, linkstarget[0]);//起始节点index\r\n                for (var i = 0; i < inputColumnNamesRelation.length; i++) {\r\n                    var index = inputColumnNamesRelation[i].index;\r\n                    var name = inputColumnNamesRelation[i].name.replace(/\\(.+\\)/g, \"\");\r\n                    var obj = new Object();\r\n                    obj.id = index;\r\n                    obj.name = name;\r\n                    inputListRelation.push(obj);\r\n                }\r\n                ;\r\n                inputDragParamRelation = {\r\n                    all: false,\r\n                    type: subType,\r\n                    sourceData: null,\r\n                    inputTableName: inputTableNameRelation,\r\n                    rows: null,\r\n                    lists: inputListRelation,\r\n                    params: []\r\n                };\r\n            }\r\n            //////////////////////////////////////////////过滤数据\r\n            //存放源数据节点数据\r\n            var inputTableSourceData = {\r\n                columnNames: inputColumnNames,\r\n                rows: []\r\n            };\r\n            var inputRow = [];//存放源数据节点 Index\r\n            //存放源数据关系节点数据\r\n            var inputTableSourceDataRelation = {\r\n                columnNames: inputColumnNamesRelation,\r\n                rows: []\r\n            };\r\n            var inputRowRelation = [];//存放源数据关系节点 Index\r\n            var inRange = [];//获取在这个范围内的\r\n\r\n            var series = chart._model.option.series;\r\n            var graphicEls = chart._chartsViews[0]._model.getData()._graphicEls;//真实值\r\n            for (var j = 0; j < series.length; j++) {\r\n                var datas = chart._model.option.series[j].data;\r\n                for (var i = 0; i < datas.length; i++) {\r\n                    var obj = datas[i];\r\n                    //dataIndex  dataType \"node\"\r\n                    for (var x = 0; x < graphicEls.length; x++) {\r\n                        var graphicEl = graphicEls[x];\r\n                        var dataIndex = graphicEl.dataIndex;\r\n                        var dataType = graphicEl.dataType;\r\n                        if (dataIndex == i && dataType == \"node\") {\r\n                            var transform = graphicEl.transform;//水平缩放绘图,水平倾斜绘图,\t垂直倾斜绘图,垂直缩放绘图,水平移动绘图,垂直移动绘图\r\n                            var realX, realY;\r\n                            if (transform) {\r\n                                realX = transform[4];\r\n                                realY = transform[5];\r\n                            } else {\r\n                                realX = graphicEl.__zr.handler._x;//真实的XY\r\n                                realY = graphicEl.__zr.handler._y;\r\n                            }\r\n                            ;\r\n                            if ((_minX <= realX && realX <= _maxX) && (_minY <= realY && realY <= _maxY)) {\r\n                                inRange.push(obj.id);\r\n                            }\r\n                            ;\r\n\r\n                        }\r\n                        ;\r\n                    }\r\n                    ;\r\n                }\r\n                ;\r\n            }\r\n            ;\r\n            //循环比较nodeID是否相等,等则存放数据\r\n            for (var i = 0; i < inputTableRows.length; i++) {\r\n                var nodeId = inputTableRows[i][nodeIDIndex];//源数据里面的节点ID\r\n                for (var j = 0; j < inRange.length; j++) {\r\n                    var rangeId = inRange[j];\r\n                    if (nodeId == rangeId) {\r\n                        inputTableSourceData['rows'].push(inputTableRows[i]);\r\n                        inputRow.push(i);\r\n                    }\r\n                    ;\r\n                }\r\n                ;\r\n            }\r\n            ;\r\n            var relationIds = [];//关联IDs\r\n            //循环比较 节点的开始节点 结束节点是否相等,等则存放数据\r\n            if (isHasRelation) {\r\n                for (var i = 0; i < inputTableRowsRelation.length; i++) {\r\n                    var linkssourceId = inputTableRowsRelation[i][linkssourceIndex];//开始节点 源数据\r\n                    var linkstargetId = inputTableRowsRelation[i][linkstargetIndex];//目标节点\r\n                    for (var j = 0; j < inRange.length; j++) {\r\n                        var rangeId = inRange[j];\r\n                        if (rangeId == linkssourceId) {\r\n                            inputTableSourceDataRelation['rows'].push(inputTableRowsRelation[i]);\r\n                            inputRowRelation.push(i);\r\n                            relationIds.push(linkstargetId);\r\n                        }\r\n                        ;\r\n                        if (linkstargetId == rangeId) {\r\n                            inputTableSourceDataRelation['rows'].push(inputTableRowsRelation[i]);\r\n                            inputRowRelation.push(i);\r\n                            relationIds.push(linkssourceId);\r\n                        }\r\n                        ;\r\n                    }\r\n                    ;\r\n                }\r\n                ;\r\n            }\r\n            if (relationIds.length > 0) {\r\n                relationIds = $.unique(relationIds);\r\n            }\r\n            //循环比较nodeID是否相等,等则存放数据\r\n            for (var i = 0; i < inputTableRows.length; i++) {\r\n                var nodeId = inputTableRows[i][nodeIDIndex];//源数据里面的节点ID\r\n                for (var j = 0; j < relationIds.length; j++) {\r\n                    var rangeId = relationIds[j];\r\n                    if (nodeId == rangeId) {\r\n                        inputTableSourceData['rows'].push(inputTableRows[i]);\r\n                        inputRow.push(i);\r\n                    }\r\n                    ;\r\n                }\r\n                ;\r\n            }\r\n            console.log(inRange.join(\",\"));\r\n            console.log(inputTableRows);\r\n            inputDragParam.sourceData = inputTableSourceData;\r\n            inputDragParam.rows = inputRow;\r\n            inputDragParam.lists = [];\r\n\r\n            //关系节点数据\r\n            this.scope.dragParam = [];\r\n            if (inputTableSourceData['rows'].length > 0) {\r\n                this.scope.dragParam.push(inputDragParam);\r\n            }\r\n            if (isHasRelation) {\r\n                inputDragParamRelation.sourceData = inputTableSourceDataRelation;\r\n                inputDragParamRelation.rows = inputRowRelation;\r\n                inputDragParamRelation.lists = [];\r\n                if (inputTableSourceDataRelation['rows'].length > 0) {\r\n                    this.scope.dragParam.push(inputDragParamRelation);\r\n                }\r\n            }\r\n            this.scope.dragSelects = {\r\n                datas: this.scope.dragParam\r\n            };\r\n        }\r\n    },\r\n//力引导画矩形\r\n    setForce:function(){\r\n        console.log(this);\r\n\r\n    },\r\n    OnMouseUp:function(evt){\r\n        if(this.p){\r\n            this.p.isDown=false\r\n        }else{\r\n            var X=evt.layerX;\r\n            var Y=evt.layerY;\r\n            var width=Math.floor(X - this.iPrevX);\r\n            var height=Math.floor(Y - this.iPrevY);\r\n            //if((this.isInit&&this.h==0)){//初始化||判断是否在矩形内,不在则清空上一次的画的内容\r\n            this.w=Math.abs(width);\r\n            this.h=Math.abs(height);\r\n            if(width>0&&height>0){\r\n                this.p=new  this.draw(this.iPrevX,this.iPrevY,this.w,this.h,this.color);\r\n                this.upperX=this.iPrevX;//上一次画的开始节点\r\n                this.upperY=this.iPrevY;\r\n            }\r\n            //}else{\r\n\r\n            /** if(!this.ctx.isPointInPath(X,Y)){//初始化||判断是否在矩形内,不在则清空上一次的画的内容,重新画矩形\r\n\t\t\t\t\t this.p=null;\r\n\t\t\t\t\t this.p=new  this.draw(this.iPrevX,this.iPrevY,this.w,this.h,this.color);\r\n\t\t\t\t }**/\r\n            // }\r\n        }\r\n\r\n    },event:function(canvas) {\r\n        canvas.addEventListener(\"mousedown\", this.OnMouseDown.bind(this), true);\r\n        //canvas.addEventListener(\"mousemove\",this.OnMouseMove.bind(this),true);\r\n        canvas.addEventListener(\"mouseup\", this.OnMouseUp.bind(this), true);\r\n    }\r\n}\r\n\r\nfunction creatData(tableName, arr, count) {\r\n    var RandomNum = function (minNum, maxNum) {\r\n        switch (arguments.length) {\r\n            case 1:\r\n                return parseInt(Math.random() * minNum + 1, 10);\r\n                break;\r\n            case 2:\r\n                return parseInt(Math.random() * (maxNum - minNum + 1) + minNum, 10);\r\n                break;\r\n            default:\r\n                return 0;\r\n                break;\r\n        }\r\n    }\r\n    for (var i = 0; i < count; i++) {\r\n        var dataFa = [];\r\n        for (var j = 0; j < arr.length; j++) {\r\n            if (arr[j] instanceof Array) {\r\n                dataFa.push(RandomNum(arr[j][0], arr[j][1]));\r\n            } else {\r\n                dataFa.push(arr[j]);\r\n            }\r\n        }\r\n        dataset[tableName].table.push(dataFa);\r\n    }\r\n}\r\n//created by xifangliang 坐标转换图专用gongj\r\n//坐标转换坐标集合,必须传入坐标类型\r\nfunction CoordinateTransformation() {\r\n    var PI = 3.1415926535897932384626;\r\n    //判断是否在国内，不在国内则不做偏移\r\n    this.out_of_china = function (lng, lat) {\r\n        var lat = +lat;\r\n        var lng = +lng;\r\n        // 纬度3.86~53.55,经度73.66~135.05\r\n        return !(lng > 73.66 && lng < 135.05 && lat > 3.86 && lat < 53.55);\r\n    };\r\n    this.transformlat = function (lng, lat) {\r\n        var lat = +lat;\r\n        var lng = +lng;\r\n        var ret = -100.0 + 2.0 * lng + 3.0 * lat + 0.2 * lat * lat + 0.1 * lng * lat + 0.2 * Math.sqrt(\r\n            Math.abs(lng));\r\n        ret += (20.0 * Math.sin(6.0 * lng * PI) + 20.0 * Math.sin(2.0 * lng * PI)) * 2.0 / 3.0;\r\n        ret += (20.0 * Math.sin(lat * PI) + 40.0 * Math.sin(lat / 3.0 * PI)) * 2.0 / 3.0;\r\n        ret += (160.0 * Math.sin(lat / 12.0 * PI) + 320 * Math.sin(lat * PI / 30.0)) * 2.0 / 3.0;\r\n        return ret\r\n    };\r\n\r\n    this.transformlng = function (lng, lat) {\r\n        var lat = +lat;\r\n        var lng = +lng;\r\n        var ret = 300.0 + lng + 2.0 * lat + 0.1 * lng * lng + 0.1 * lng * lat + 0.1 * Math.sqrt(\r\n            Math.abs(lng));\r\n        ret += (20.0 * Math.sin(6.0 * lng * PI) + 20.0 * Math.sin(2.0 * lng * PI)) * 2.0 / 3.0;\r\n        ret += (20.0 * Math.sin(lng * PI) + 40.0 * Math.sin(lng / 3.0 * PI)) * 2.0 / 3.0;\r\n        ret += (150.0 * Math.sin(lng / 12.0 * PI) + 300.0 * Math.sin(lng / 30.0 * PI)) * 2.0 / 3.0;\r\n        return ret\r\n    };\r\n};\r\nCoordinateTransformation.prototype = {\r\n    bd09togcj02: function (lng, lat) {\r\n        var x_PI = 3.14159265358979324 * 3000.0 / 180.0;\r\n        var lng = +lng;\r\n        var lat = +lat;\r\n        var x = lng - 0.0065;\r\n        var y = lat - 0.006;\r\n        var z = Math.sqrt(x * x + y * y) - 0.00002 * Math.sin(y * x_PI);\r\n        var theta = Math.atan2(y, x) - 0.000003 * Math.cos(x * x_PI);\r\n        var gg_lng = z * Math.cos(theta);\r\n        var gg_lat = z * Math.sin(theta);\r\n        return [gg_lng, gg_lat]\r\n    },\r\n    gcj02tobd09: function (lng, lat) {\r\n        var x_PI = 3.14159265358979324 * 3000.0 / 180.0;\r\n        var lat = +lat;\r\n        var lng = +lng;\r\n        var z = Math.sqrt(lng * lng + lat * lat) + 0.00002 * Math.sin(lat * x_PI);\r\n        var theta = Math.atan2(lat, lng) + 0.000003 * Math.cos(lng * x_PI);\r\n        var bd_lng = z * Math.cos(theta) + 0.0065;\r\n        var bd_lat = z * Math.sin(theta) + 0.006;\r\n        return [bd_lng, bd_lat]\r\n    },\r\n    wgs84togcj02: function (lng, lat) {\r\n        var PI = 3.1415926535897932384626;\r\n        var a = 6378245.0;\r\n        var ee = 0.00669342162296594323;\r\n        var lat = +lat;\r\n        var lng = +lng;\r\n        if (this.out_of_china(lng, lat)) {\r\n            return [lng, lat]\r\n        } else {\r\n            var dlat = this.transformlat(lng - 105.0, lat - 35.0);\r\n            var dlng = this.transformlng(lng - 105.0, lat - 35.0);\r\n            var radlat = lat / 180.0 * PI;\r\n            var magic = Math.sin(radlat);\r\n            magic = 1 - ee * magic * magic;\r\n            var sqrtmagic = Math.sqrt(magic);\r\n            dlat = (dlat * 180.0) / ((a * (1 - ee)) / (magic * sqrtmagic) * PI);\r\n            dlng = (dlng * 180.0) / (a / sqrtmagic * Math.cos(radlat) * PI);\r\n            var mglat = lat + dlat;\r\n            var mglng = lng + dlng;\r\n            return [mglng, mglat]\r\n        }\r\n    },\r\n    gcj02towgs84: function (lng, lat) {\r\n        var PI = 3.1415926535897932384626;\r\n        var a = 6378245.0;\r\n        var ee = 0.00669342162296594323;\r\n        var lat = +lat;\r\n        var lng = +lng;\r\n        if (this.out_of_china(lng, lat)) {\r\n            return [lng, lat]\r\n        } else {\r\n            var dlat = this.transformlat(lng - 105.0, lat - 35.0);\r\n            var dlng = this.transformlng(lng - 105.0, lat - 35.0);\r\n            var radlat = lat / 180.0 * PI;\r\n            var magic = Math.sin(radlat);\r\n            magic = 1 - ee * magic * magic;\r\n            var sqrtmagic = Math.sqrt(magic);\r\n            dlat = (dlat * 180.0) / ((a * (1 - ee)) / (magic * sqrtmagic) * PI);\r\n            dlng = (dlng * 180.0) / (a / sqrtmagic * Math.cos(radlat) * PI);\r\n            var mglat = lat + dlat;\r\n            var mglng = lng + dlng;\r\n            return [lng * 2 - mglng, lat * 2 - mglat]\r\n        }\r\n    }\r\n}\r\nvar coordinateTransformation = new CoordinateTransformation();\r\n//默认转goGoogleCoord方法\r\nfunction goGoogleCoord(lonAndLat, coordinateType) {\r\n    var longitude = lonAndLat[0];\r\n    var latitude = lonAndLat[1];\r\n    if (coordinateType == \"BD09\") {\r\n        return coordinateTransformation.bd09togcj02(longitude, latitude);;\r\n    } else if (coordinateType == \"GCJ02\") {\r\n        return [longitude, latitude];\r\n    } else if (coordinateType == \"WGS84\") {\r\n        return coordinateTransformation.wgs84togcj02(longitude, latitude);\r\n    }\r\n}\r\n\r\n//新增转WGS84方法\r\nfunction goWGS84Coord(lonAndLat, coordinateType) {\r\n    var longitude = lonAndLat[0];\r\n    var latitude = lonAndLat[1];\r\n    if (coordinateType == \"BD09\") {\r\n        var loAndLa = coordinateTransformation.bd09togcj02(longitude, latitude);\r\n        return coordinateTransformation.gcj02towgs84(loAndLa[0], loAndLa[1]);\r\n    } else if (coordinateType == \"GCJ02\") {\r\n        return coordinateTransformation.gcj02towgs84(longitude, latitude);\r\n    } else if (coordinateType == \"WGS84\") {\r\n        return [longitude, latitude];\r\n    }\r\n}\r\n//新增转BD09方法\r\nfunction goBD09Coord(lonAndLat, coordinateType) {\r\n    var longitude = lonAndLat[0];\r\n    var latitude = lonAndLat[1];\r\n    if (coordinateType == \"BD09\") {\r\n        return [longitude, latitude];\r\n    } else if (coordinateType == \"GCJ02\") {\r\n        return coordinateTransformation.gcj02tobd09(longitude, latitude);\r\n    } else if (coordinateType == \"WGS84\") {\r\n        var loAndLa = coordinateTransformation.wgs84togcj02(longitude, latitude);\r\n        return coordinateTransformation.gcj02tobd09(loAndLa[0], loAndLa[1]);\r\n        return [longitude, latitude];\r\n    }\r\n}\r\n\r\nfunction getColor(arr) {\r\n    var color = [\"#27727b\", \"#fcce10\", \"#e87c25\", \"#b5c334\", \"#fe8463\", \"#9bca63\", \"#fad860\",\r\n        \"#f3a43b\", \"#60c0dd\", \"#d7504b\", \"#c6e579\", \"#f4e001\", \"#f0805a\", \"#26c0c0\", \"#8B6969\",\r\n        \"#7171C6\", \"#40E0D0\", \"#00E5EE\", \"#0000CD\", \"#DEB887\"\r\n    ];\r\n\r\n    function RandomNum(Min, Max) {\r\n        var Range = Max - Min;\r\n        var Rand = Math.random();\r\n        var num = Min + Math.floor(Rand * Range); //舍去\r\n        return num;\r\n    }\r\n    var cArr = [];\r\n    for (var i = 0; i < arr.length; i++) {\r\n        if (arr.length < 20) {\r\n            cArr[i] = color[i];\r\n        } else {\r\n            cArr[i] = \"rgb(\" + RandomNum(0, 255) + \",\" + RandomNum(0, 255) + \",\" + RandomNum(0, 255) + \")\";\r\n        }\r\n    }\r\n    return cArr;\r\n}\r\nArray.prototype.arrUniq = function () {\r\n    var temp, arrVal,\r\n        array = this,\r\n        arrClone = array.concat(), //克隆数组\r\n        typeArr = { //数组原型\r\n            'obj': '[object Object]',\r\n            'fun': '[object Function]',\r\n            'arr': '[object Array]',\r\n            'num': '[object Number]'\r\n        },\r\n        ent = /(\\u3000|\\s|\\t)*(\\n)+(\\u3000|\\s|\\t)*/gi; //空白字符正则\r\n\r\n    //把数组中的object和function转换为字符串形式\r\n    for (var i = arrClone.length; i--;) {\r\n        arrVal = arrClone[i];\r\n        temp = Object.prototype.toString.call(arrVal);\r\n\r\n        if (temp == typeArr['num'] && arrVal.toString() == 'NaN') {\r\n            arrClone[i] = arrVal.toString();\r\n        }\r\n\r\n        if (temp == typeArr['obj']) {\r\n            arrClone[i] = JSON.stringify(arrVal);\r\n        }\r\n\r\n        if (temp == typeArr['fun']) {\r\n            arrClone[i] = arrVal.toString().replace(ent, '');\r\n        }\r\n    }\r\n\r\n    //去重关键步骤\r\n    for (var i = arrClone.length; i--;) {\r\n        arrVal = arrClone[i];\r\n        temp = Object.prototype.toString.call(arrVal);\r\n\r\n        if (temp == typeArr['arr']) arrVal.arrUniq(); //如果数组中有数组，则递归\r\n        if (arrClone.indexOf(arrVal) != arrClone.lastIndexOf(arrVal)) { //如果有重复的，则去重\r\n            array.splice(i, 1);\r\n            arrClone.splice(i, 1);\r\n        } else {\r\n            if (Object.prototype.toString.call(array[i]) != temp) {\r\n                //检查现在数组和原始数组的值类型是否相同，如果不同则用原数组中的替换，原因是原数组经过了字符串变换\r\n                arrClone[i] = array[i];\r\n            }\r\n        }\r\n    }\r\n    return arrClone;\r\n}\r\n\r\nfunction getListData(data, listIndex) {\r\n    var dataArray = [];\r\n    for (var j = 0; j < data.length; j++) {\r\n        dataArray.push(data[j][listIndex])\r\n    }\r\n    return dataArray;\r\n}\r\nvar saveAs = saveAs || function (e) {\r\n    \"use strict\";\r\n    if (typeof e === \"undefined\" || typeof navigator !== \"undefined\" && /MSIE [1-9]\\./.test(\r\n            navigator.userAgent)) {\r\n        return\r\n    }\r\n    var t = e.document,\r\n        n = function () {\r\n            return e.URL || e.webkitURL || e\r\n        },\r\n        r = t.createElementNS(\"http://www.w3.org/1999/xhtml\", \"a\"),\r\n        o = \"download\" in r,\r\n        a = function (e) {\r\n            var t = new MouseEvent(\"click\");\r\n            e.dispatchEvent(t)\r\n        },\r\n        i = /constructor/i.test(e.HTMLElement) || e.safari,\r\n        f = /CriOS\\/[\\d]+/.test(navigator.userAgent),\r\n        u = function (t) {\r\n            (e.setImmediate || e.setTimeout)(function () {\r\n                throw t\r\n            }, 0)\r\n        },\r\n        s = \"application/octet-stream\",\r\n        d = 1e3 * 40,\r\n        c = function (e) {\r\n            var t = function () {\r\n                if (typeof e === \"string\") {\r\n                    n().revokeObjectURL(e)\r\n                } else {\r\n                    e.remove()\r\n                }\r\n            };\r\n            setTimeout(t, d)\r\n        },\r\n        l = function (e, t, n) {\r\n            t = [].concat(t);\r\n            var r = t.length;\r\n            while (r--) {\r\n                var o = e[\"on\" + t[r]];\r\n                if (typeof o === \"function\") {\r\n                    try {\r\n                        o.call(e, n || e)\r\n                    } catch (a) {\r\n                        u(a)\r\n                    }\r\n                }\r\n            }\r\n        },\r\n        p = function (e) {\r\n            if (\r\n                /^\\s*(?:text\\/\\S*|application\\/xml|\\S*\\/\\S*\\+xml)\\s*;.*charset\\s*=\\s*utf-8/i\r\n                    .test(e.type)) {\r\n                return new Blob([String.fromCharCode(65279), e], {\r\n                    type: e.type\r\n                })\r\n            }\r\n            return e\r\n        },\r\n        v = function (t, u, d) {\r\n            if (!d) {\r\n                t = p(t)\r\n            }\r\n            var v = this,\r\n                w = t.type,\r\n                m = w === s,\r\n                y, h = function () {\r\n                    l(v, \"writestart progress write writeend\".split(\" \"))\r\n                },\r\n                S = function () {\r\n                    if ((f || m && i) && e.FileReader) {\r\n                        var r = new FileReader;\r\n                        r.onloadend = function () {\r\n                            var t = f ? r.result : r.result.replace(/^data:[^;]*;/,\r\n                                \"data:attachment/file;\");\r\n                            var n = e.open(t, \"_blank\");\r\n                            if (!n) e.location.href = t;\r\n                            t = undefined;\r\n                            v.readyState = v.DONE;\r\n                            h()\r\n                        };\r\n                        r.readAsDataURL(t);\r\n                        v.readyState = v.INIT;\r\n                        return\r\n                    }\r\n                    if (!y) {\r\n                        y = n().createObjectURL(t)\r\n                    }\r\n                    if (m) {\r\n                        e.location.href = y\r\n                    } else {\r\n                        var o = e.open(y, \"_blank\");\r\n                        if (!o) {\r\n                            e.location.href = y\r\n                        }\r\n                    }\r\n                    v.readyState = v.DONE;\r\n                    h();\r\n                    c(y)\r\n                };\r\n            v.readyState = v.INIT;\r\n            if (o) {\r\n                y = n().createObjectURL(t);\r\n                setTimeout(function () {\r\n                    r.href = y;\r\n                    r.download = u;\r\n                    a(r);\r\n                    h();\r\n                    c(y);\r\n                    v.readyState = v.DONE\r\n                });\r\n                return\r\n            }\r\n            S()\r\n        },\r\n        w = v.prototype,\r\n        m = function (e, t, n) {\r\n            return new v(e, t || e.name || \"download\", n)\r\n        };\r\n    if (typeof navigator !== \"undefined\" && navigator.msSaveOrOpenBlob) {\r\n        return function (e, t, n) {\r\n            t = t || e.name || \"download\";\r\n            if (!n) {\r\n                e = p(e)\r\n            }\r\n            return navigator.msSaveOrOpenBlob(e, t)\r\n        }\r\n    }\r\n    w.abort = function () {};\r\n    w.readyState = w.INIT = 0;\r\n    w.WRITING = 1;\r\n    w.DONE = 2;\r\n    w.error = w.onwritestart = w.onprogress = w.onwrite = w.onabort = w.onerror = w.onwriteend =\r\n        null;\r\n    return m\r\n}(typeof self !== \"undefined\" && self || typeof window !== \"undefined\" && window || this.content);\r\nif ( true && module.exports) {\r\n    module.exports.saveAs = saveAs\r\n} else if ( true && __webpack_require__(/*! !webpack amd define */ \"./node_modules/webpack/buildin/amd-define.js\") !== null && __webpack_require__(/*! !webpack amd options */ \"./node_modules/webpack/buildin/amd-options.js\") !== null) {\r\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\r\n        return saveAs\r\n    }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\r\n}\r\n$.extend(window,{\r\n    createBrush: createBrush,\r\n    RandomNumBetween: RandomNumBetween,\r\n    getIndex: getIndex,\r\n    checkDataType: checkDataType,\r\n    checkTypeTy: checkTypeTy,\r\n    promptExceptionData: promptExceptionData,\r\n    creatData: creatData,\r\n    DrawBrush: DrawBrush,\r\n    goGoogleCoord: goGoogleCoord,\r\n    goWGS84Coord: goWGS84Coord,\r\n    goBD09Coord: goBD09Coord,\r\n    getColor: getColor,\r\n    getListData: getListData,\r\n});\n\n//# sourceURL=webpack://zzjzAppLib/./src/module/Chart.js?");

/***/ }),

/***/ "./src/module/appServer.js":
/*!*********************************!*\
  !*** ./src/module/appServer.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\r\n * @description appSDK的前后端交互接口服务\r\n * */\r\n\r\n\r\n// 模块引用\r\nvar $ = __webpack_require__(/*! ./zepto */ \"./src/module/zepto.js\");\r\nvar host = window.config.nodeServer ;\r\nvar cases;\r\nvar comMap = {};\r\n/*var defer = new $.Deferred();\r\n$.get('./config.json').then(function (data) {\r\n   host = data.nodeServer;\r\n});*/\r\nvar service = {\r\n    jsonp: function (url) {\r\n        return $.ajax({\r\n            url : url,\r\n            type : 'get',\r\n            dataType : 'jsonp'\r\n        })\r\n    },\r\n    getAppDataById: function (id) {\r\n        return this.jsonp(host + '/rest/getAppById'+'?appId='+id);\r\n    },\r\n    getAppByAppName: function (appName,userName) {\r\n        return this.jsonp(host + '/rest/getAppByAppName'+'?appName='+appName+'&userName='+userName);\r\n    },\r\n    runApp: function (id,paramSetting) {\r\n        return this.jsonp(host + '/rest/runAppGetChartData'+'?appId='+id+'&params='+JSON.stringify(paramSetting));\r\n    },\r\n    runLinkage: function (id,linkageId,selectedData) {\r\n        return this.jsonp(host + '/rest/runLinkage'+'?appId='+id+'&linkageId='+linkageId+'&selectedData='+JSON.stringify(selectedData));\r\n    },\r\n    refreshCase: function () {\r\n        return this.jsonp(host + '/rest/getCase').then(function (result) {\r\n            if(result.status === 'OK' && result.data){\r\n                cases = result.data;\r\n            }else {\r\n                console.error('获取图元信息错误!');\r\n            }\r\n            return result;\r\n        });\r\n    },\r\n    getCaseCharts: function (name) {\r\n        var cases = service.getCases();\r\n        var result = {};\r\n        var arr = [];\r\n        if(cases) {\r\n            for (var mark in cases) {\r\n                if (mark && cases[mark]) {\r\n                    var chcases = cases[mark];\r\n                    for (var cn in chcases) {\r\n                        if (cn === name && chcases[cn]) {\r\n                            var chartIds = chcases[cn];\r\n                            for (var i = 0; i < chartIds.length; i++) {\r\n                                //console.log(chartIds[i]);\r\n                                var chart = comMap[chartIds[i]];\r\n                                if (chart) {\r\n                                    //过滤，仅保留最新版本的图元\r\n                                    if (!result[chart.sn]) {\r\n                                        result[chart.sn] = {};\r\n                                        result[chart.sn] = chart;\r\n                                    } else {\r\n                                        if (chart.version > result[chart.sn].version) {\r\n                                            result[chart.sn] = chart;\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            //转成数组\r\n            for (var sn in result) {\r\n                if (result[sn] && typeof(result[sn]) === \"object\") {\r\n                    arr.push(result[sn]);\r\n                }\r\n            }\r\n        }else {\r\n            service.refreshCase();\r\n            console.warn('图元cases信息读取错误!');\r\n        }\r\n        return arr;\r\n    },\r\n    getCases:function () {\r\n        return cases;\r\n    },\r\n    setHost: function (_host) {\r\n        if(_host) {\r\n            host = _host;\r\n            service.refreshCase();\r\n        }\r\n    },\r\n    setComMap: function (_comMap) {\r\n        $.extend(comMap,_comMap);\r\n    },\r\n    getComMap: function () {\r\n        return comMap;\r\n    }\r\n};\r\nservice.refreshCase();\r\nmodule.exports = service;\n\n//# sourceURL=webpack://zzjzAppLib/./src/module/appServer.js?");

/***/ }),

/***/ "./src/module/chartContainer.js":
/*!**************************************!*\
  !*** ./src/module/chartContainer.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var $ = __webpack_require__(/*! ./zepto */ \"./src/module/zepto.js\");\r\n//图元入口文件\r\nfunction ctnInit(plugins){\r\n    // code...\r\n    console.log(plugins);\r\n\r\n    var defer = $.Deferred(); //创建defer对象\r\n\r\n    if($.isObject(plugins)){\r\n        var multiFileObj = {};\r\n        var jsTplArr = [];\r\n        var pluginStr = plugins.plugin;\r\n        var idx = plugins.variables.indexOf(\",\");\r\n        var variablesArr = [];\r\n        var flag = 0;\r\n\r\n        if(idx > 0){\r\n            variablesArr = plugins.variables.split(\",\");\r\n        }else{\r\n            variablesArr.push(plugins.variables);\r\n        }\r\n\r\n        if(plugins.js && plugins.js.length > 0){\r\n            plugins.js.forEach( function (node, num) {\r\n                //异步操作\r\n                getChartPlugin(pluginStr + node.param.url).then(function(res){\r\n                    console.debug(\"res object is %o\", res);\r\n                    flag++;\r\n                    jsTplArr[num] = res;\r\n\r\n                    //判断是否执行完所有Promise异步操作\r\n                    if(flag === plugins.js.length){\r\n                        var chartLib = new chartLibPlugin(jsTplArr, variablesArr);\r\n                        console.debug(\"pluginObj object is %o\", chartLib);\r\n                        multiFileObj = chartLib.pluginObj;\r\n                        console.debug(\"multiFileObj object is %o\", multiFileObj);\r\n                        defer.resolve(multiFileObj);\r\n                    }\r\n                }, function error(res){\r\n                    console.log('第三方资源加载失败！');\r\n                    defer.reject(res);\r\n                });\r\n            });\r\n        }\r\n\r\n        return defer.promise\r\n    }else{\r\n    }\r\n}\r\n\r\n//获取图元插件\r\nfunction getChartPlugin(url, num){\r\n    var defer = $.Deferred(); //创建defer对象\r\n\r\n    $.get(url).then(function success(res) {\r\n        if(res.status === 200){\r\n            var jsTpl = res.data;\r\n\r\n            defer.resolve(jsTpl);\r\n        }else{\r\n            console.log('第三方资源请求失败！');\r\n            defer.reject(res);\r\n        }\r\n    }, function error(res){\r\n        console.log('第三方资源请求失败！');\r\n        defer.reject(res);\r\n    });\r\n\r\n    return defer.promise\r\n}\r\n\r\n//插件封装\r\nfunction chartLibPlugin(jsTplArr, variablesArr){\r\n    var pluginObj = {};\r\n    var _self = this;\r\n\r\n    //执行第三方插件\r\n    for(var i=0; i<jsTplArr.length; i++){\r\n        eval(jsTplArr[i]);\r\n    }\r\n\r\n    //获取对象\r\n    variablesArr.forEach(function (node) {\r\n        pluginObj[node] = _self[node];//$.copy(_self[node])\r\n        //delete _self[node];\r\n    });\r\n\r\n    _self.pluginObj = pluginObj;\r\n}\r\n\r\nmodule.exports = {\r\n    ctnInit: ctnInit\r\n};\n\n//# sourceURL=webpack://zzjzAppLib/./src/module/chartContainer.js?");

/***/ }),

/***/ "./src/module/comClass.js":
/*!********************************!*\
  !*** ./src/module/comClass.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\r\n * @author cai.liao\r\n * SDK 中comClass 只需要实现com.template.renderFuncObj构造相关功能其他代码不进行移植\r\n * */\r\n\r\n\r\n/**\r\n * 图元算子模板类。该类只能通过new方法实例化：new ChartComTemplate(jsonObj)\r\n * @constructor\r\n */\r\nfunction ChartComTemplate() {\r\n    var templateSelf = this;\r\n\r\n    //函数定义\r\n    /**\r\n     * 加载算子模板的JSON对象。该方法是静态调用。\r\n     * @param instance 模板对象实例\r\n     * @param data 模板的JSON对象\r\n     * @returns {load} 返回算子模板自身\r\n     */\r\n    function loadOrigin(instance, data) {\r\n        if (!data || typeof(data) !== \"object\") {\r\n            return instance;\r\n        } else {\r\n            //嵌套的参数模型\r\n            for (var key in data) {\r\n                var value = data[key];\r\n                if (typeof(value) != \"function\") {\r\n                    if (key != \"paramList\") {\r\n                        instance[key] = value;\r\n                    }\r\n                }\r\n            }\r\n            instance._changed = false;\r\n        }\r\n    }\r\n    //函数定义\r\n    /**\r\n     * 加载算子模板的JSON对象。该方法不是静态调用。\r\n     * @param data 模板的JSON对象\r\n     * @returns {load} 返回算子模板自身\r\n     */\r\n    function load(instance, data) {\r\n        loadOrigin(instance, data);\r\n        setDefaultFunc(instance);\r\n        //构造函数对象\r\n        buildFuncObject(instance, data);\r\n        return instance;\r\n    }\r\n\r\n    /**\r\n     * 将Javascript代码文本转化为可调用的函数对象\r\n     * @param funcStr Javascript代码文本\r\n     * @returns {*} 可调用的函数对象\r\n     */\r\n    function buildJsFuncObject(funcStr) {\r\n        if (!funcStr || funcStr.length == 0) {\r\n            return undefined;\r\n        }\r\n        var fproto = \"try{__FUNC__.<#FuncName#>=<#FuncName#>;}catch(ex){/*console.warn('ComTemplate.buildJsFuncObject异常：%s',ex);*/}\\n\";\r\n        var fstr = \"\";\r\n        //查找“function XXX (”字符串，提取函数名\r\n        var match = /function\\s+([a-zA-Z_$][0-9a-zA-Z_$]+)\\s*\\(/g;\r\n        var funcNames = [];\r\n        var func = match.exec(funcStr);\r\n        while (match.lastIndex > 0) {\r\n            funcNames.push(func[1]);\r\n            func = match.exec(funcStr);\r\n        }\r\n        //查找到“function XXX (”字符串，提取函数名\r\n        funcNames.forEach(function (x) {\r\n            fstr += fproto.replace(/<#FuncName#>/g, x);\r\n        });\r\n        var funcObj = undefined;\r\n        if (fstr.length > 0) {\r\n            fstr = funcStr + \"\\nvar __FUNC__={};\\n\" + fstr + \"\\nreturn __FUNC__;\";\r\n            var fobj = null;\r\n            try {\r\n                fobj = new Function(fstr);\r\n            } catch (ex) {\r\n                console.warn(\"ComTemplate.buildJsFuncObject异常：%s\", ex);\r\n                return undefined;\r\n            }\r\n            try {\r\n                funcObj = fobj();\r\n            } catch (ex) {\r\n                console.warn(\"ComTemplate.buildJsFuncObject异常：%s\", ex);\r\n            }\r\n        }\r\n        return funcObj;\r\n    }\r\n\r\n    function buildFuncObject(instance, data) {\r\n        //构造函数对象\r\n        var renderStr = \"function init(initArgs,theme){\\n\" + instance.initFunc + \"\\n}\\n\";\r\n        renderStr += \"function load(charts,initArgs,theme,dataset){\\n\" + instance.loadFunc + \"\\n}\\n\";\r\n        renderStr += \"function events(charts,initArgs,theme){\\n\" + instance.eventsFunc + \"\\n}\\n\";\r\n        renderStr += \"\\\r\nfunction close(charts){\\n\\\r\n  try{\\n\"+\r\n            instance.closeFunc + \"\\n\\\r\n  }catch(ex){\\n\\\r\n    console.warn('回收图元对象异常：%o',ex);\\n\\\r\n  }\\n\\\r\n}\\n\";\r\n        if (data.renderFunc) {\r\n            renderStr += \"function render(charts,initArgs,theme,dataset){\\n\" + data.renderFunc + \"\\n}\\n\";\r\n        } else {\r\n            renderStr += \"\\\r\nfunction render(charts,initArgs,theme,dataset){\\n\\\r\n  if(!charts){\\n\\\r\n    try{\\n\\\r\n      charts=init(initArgs,theme);\\n\\\r\n    }catch(ex){\\n\\\r\n      console.warn('初始化图元对象异常：%o',ex);\\n\\\r\n      return;\\n\\\r\n    }\\n\\\r\n    try{\\n\\\r\n      events(charts,initArgs,theme);\\n\\\r\n    }catch(ex){\\n\\\r\n      console.warn('设定图元事件异常：%o',ex);\\n\\\r\n      return;\\n\\\r\n    }\\n\\\r\n  }\\n\\\r\n  try{\\n\\\r\n    load(charts,initArgs,theme,dataset);\\n\\\r\n  }catch(ex){console.warn('加载图元数据渲染异常：%o',ex);}\\n\\\r\n  return charts;\\n\\\r\n}\\n\";\r\n        }\r\n        instance.renderFuncObj = buildJsFuncObject(renderStr);\r\n        return instance;\r\n    }\r\n\r\n    function setDefaultFunc(instance) {\r\n        //设定init、events、load、close函数帮助\r\n        if (!instance.initFunc) {\r\n            instance.initFunc = \"\\\r\n//输入变量：\\n\\\r\n//initArgs：初始化参数，和需要用到全局服务或配置\\n\\\r\n//theme：呈现主题（色系、皮肤等等）\\n\\\r\n//返回值：图元对象。\\n\";\r\n        }\r\n        if (!instance.eventsFunc) {\r\n            instance.eventsFunc = \"\\\r\n//输入变量：\\n\\\r\n//charts：init函数返回的图元对象\\n\\\r\n//initArgs：初始化参数，和需要用到全局服务或配置\\n\\\r\n//theme：呈现主题（色系、皮肤等等）\\n\\\r\n//返回值：图元对象。\\n\";\r\n        }\r\n        if (!instance.loadFunc) {\r\n            instance.loadFunc = \"\\\r\n//输入变量：\\n\\\r\n//charts：init函数返回的图元对象\\n\\\r\n//initArgs：初始化参数，和需要用到全局服务或配置\\n\\\r\n//theme：呈现主题（色系、皮肤等等）\\n\\\r\n//dataset：需要加载的数据集\\n\\\r\n//返回值：图元对象。\\n\";\r\n        }\r\n        if (!instance.closeFunc) {\r\n            instance.closeFunc = \"\\\r\n//输入变量：\\n\\\r\n//charts：init函数返回的图元对象\\n\";\r\n        }\r\n    }\r\n\r\n    //原型方法\r\n    if (ChartComTemplate.prototype.__initChartComTemplate__ !== true) {\r\n        ChartComTemplate.prototype.__initChartComTemplate__ = true;\r\n    }\r\n\r\n    //初始化或构造函数\r\n    var argn = arguments.length;\r\n    if (argn == 1) {\r\n        load(templateSelf, arguments[0]);\r\n    } else {\r\n        //设定init、events、load、close函数帮助\r\n        setDefaultFunc(templateSelf);\r\n    }\r\n\r\n}\r\n\r\n\r\nfunction initChartComRenderFuncObj(data) {\r\n    if(data && data.template && typeof data.template === 'string') {\r\n        data.template = JSON.parse(data.template);\r\n    }\r\n    if(data && data.template && typeof data.template === 'object') {\r\n        data.template = new ChartComTemplate(data[\"template\"]);\r\n    }\r\n}\r\nmodule.exports = {\r\n    initChartComRenderFuncObj: initChartComRenderFuncObj\r\n};\n\n//# sourceURL=webpack://zzjzAppLib/./src/module/comClass.js?");

/***/ }),

/***/ "./src/module/zepto.js":
/*!*****************************!*\
  !*** ./src/module/zepto.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * @description 使用webpack的方法调用zepto并且修改添加部分常用接口\n * */\n\nvar Zepto = (function() {\n  var undefined, key, $, classList, emptyArray = [], concat = emptyArray.concat, filter = emptyArray.filter, slice = emptyArray.slice,\n    document = window.document,\n    elementDisplay = {}, classCache = {},\n    cssNumber = { 'column-count': 1, 'columns': 1, 'font-weight': 1, 'line-height': 1,'opacity': 1, 'z-index': 1, 'zoom': 1 },\n    fragmentRE = /^\\s*<(\\w+|!)[^>]*>/,\n    singleTagRE = /^<(\\w+)\\s*\\/?>(?:<\\/\\1>|)$/,\n    tagExpanderRE = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^>]*)\\/>/ig,\n    rootNodeRE = /^(?:body|html)$/i,\n    capitalRE = /([A-Z])/g,\n\n    // special attributes that should be get/set via method calls\n    methodAttributes = ['val', 'css', 'html', 'text', 'data', 'width', 'height', 'offset'],\n\n    adjacencyOperators = [ 'after', 'prepend', 'before', 'append' ],\n    table = document.createElement('table'),\n    tableRow = document.createElement('tr'),\n    containers = {\n      'tr': document.createElement('tbody'),\n      'tbody': table, 'thead': table, 'tfoot': table,\n      'td': tableRow, 'th': tableRow,\n      '*': document.createElement('div')\n    },\n    readyRE = /complete|loaded|interactive/,\n    simpleSelectorRE = /^[\\w-]*$/,\n    class2type = {},\n    toString = class2type.toString,\n    zepto = {},\n    camelize, uniq,\n    tempParent = document.createElement('div'),\n    propMap = {\n      'tabindex': 'tabIndex',\n      'readonly': 'readOnly',\n      'for': 'htmlFor',\n      'class': 'className',\n      'maxlength': 'maxLength',\n      'cellspacing': 'cellSpacing',\n      'cellpadding': 'cellPadding',\n      'rowspan': 'rowSpan',\n      'colspan': 'colSpan',\n      'usemap': 'useMap',\n      'frameborder': 'frameBorder',\n      'contenteditable': 'contentEditable'\n    },\n    isArray = Array.isArray ||\n      function(object){ return object instanceof Array }\n\n  zepto.matches = function(element, selector) {\n    if (!selector || !element || element.nodeType !== 1) return false\n    var matchesSelector = element.matches || element.webkitMatchesSelector ||\n                          element.mozMatchesSelector || element.oMatchesSelector ||\n                          element.matchesSelector\n    if (matchesSelector) return matchesSelector.call(element, selector)\n    // fall back to performing a selector:\n    var match, parent = element.parentNode, temp = !parent\n    if (temp) (parent = tempParent).appendChild(element)\n    match = ~zepto.qsa(parent, selector).indexOf(element)\n    temp && tempParent.removeChild(element)\n    return match\n  }\n\n  function type(obj) {\n    return obj == null ? String(obj) :\n      class2type[toString.call(obj)] || \"object\"\n  }\n\n  function isFunction(value) { return type(value) == \"function\" }\n  function isWindow(obj)     { return obj != null && obj == obj.window }\n  function isDocument(obj)   { return obj != null && obj.nodeType == obj.DOCUMENT_NODE }\n  function isObject(obj)     { return type(obj) == \"object\" }\n  function isPlainObject(obj) {\n    return isObject(obj) && !isWindow(obj) && Object.getPrototypeOf(obj) == Object.prototype\n  }\n\n  function likeArray(obj) {\n    var length = !!obj && 'length' in obj && obj.length,\n      type = $.type(obj)\n\n    return 'function' != type && !isWindow(obj) && (\n      'array' == type || length === 0 ||\n        (typeof length == 'number' && length > 0 && (length - 1) in obj)\n    )\n  }\n\n  function compact(array) { return filter.call(array, function(item){ return item != null }) }\n  function flatten(array) { return array.length > 0 ? $.fn.concat.apply([], array) : array }\n  camelize = function(str){ return str.replace(/-+(.)?/g, function(match, chr){ return chr ? chr.toUpperCase() : '' }) }\n  function dasherize(str) {\n    return str.replace(/::/g, '/')\n           .replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2')\n           .replace(/([a-z\\d])([A-Z])/g, '$1_$2')\n           .replace(/_/g, '-')\n           .toLowerCase()\n  }\n  uniq = function(array){ return filter.call(array, function(item, idx){ return array.indexOf(item) == idx }) }\n\n  function classRE(name) {\n    return name in classCache ?\n      classCache[name] : (classCache[name] = new RegExp('(^|\\\\s)' + name + '(\\\\s|$)'))\n  }\n\n  function maybeAddPx(name, value) {\n    return (typeof value == \"number\" && !cssNumber[dasherize(name)]) ? value + \"px\" : value\n  }\n\n  function defaultDisplay(nodeName) {\n    var element, display\n    if (!elementDisplay[nodeName]) {\n      element = document.createElement(nodeName)\n      document.body.appendChild(element)\n      display = getComputedStyle(element, '').getPropertyValue(\"display\")\n      element.parentNode.removeChild(element)\n      display == \"none\" && (display = \"block\")\n      elementDisplay[nodeName] = display\n    }\n    return elementDisplay[nodeName]\n  }\n\n  function children(element) {\n    return 'children' in element ?\n      slice.call(element.children) :\n      $.map(element.childNodes, function(node){ if (node.nodeType == 1) return node })\n  }\n\n  function Z(dom, selector) {\n    var i, len = dom ? dom.length : 0\n    for (i = 0; i < len; i++) this[i] = dom[i]\n    this.length = len\n    this.selector = selector || ''\n  }\n\n  // `$.zepto.fragment` takes a html string and an optional tag name\n  // to generate DOM nodes from the given html string.\n  // The generated DOM nodes are returned as an array.\n  // This function can be overridden in plugins for example to make\n  // it compatible with browsers that don't support the DOM fully.\n  zepto.fragment = function(html, name, properties) {\n    var dom, nodes, container\n\n    // A special case optimization for a single tag\n    if (singleTagRE.test(html)) dom = $(document.createElement(RegExp.$1))\n\n    if (!dom) {\n      if (html.replace) html = html.replace(tagExpanderRE, \"<$1></$2>\")\n      if (name === undefined) name = fragmentRE.test(html) && RegExp.$1\n      if (!(name in containers)) name = '*'\n\n      container = containers[name]\n      container.innerHTML = '' + html\n      dom = $.each(slice.call(container.childNodes), function(){\n        container.removeChild(this)\n      })\n    }\n\n    if (isPlainObject(properties)) {\n      nodes = $(dom)\n      $.each(properties, function(key, value) {\n        if (methodAttributes.indexOf(key) > -1) nodes[key](value)\n        else nodes.attr(key, value)\n      })\n    }\n\n    return dom\n  }\n\n  // `$.zepto.Z` swaps out the prototype of the given `dom` array\n  // of nodes with `$.fn` and thus supplying all the Zepto functions\n  // to the array. This method can be overridden in plugins.\n  zepto.Z = function(dom, selector) {\n    return new Z(dom, selector)\n  }\n\n  // `$.zepto.isZ` should return `true` if the given object is a Zepto\n  // collection. This method can be overridden in plugins.\n  zepto.isZ = function(object) {\n    return object instanceof zepto.Z\n  }\n\n  // `$.zepto.init` is Zepto's counterpart to jQuery's `$.fn.init` and\n  // takes a CSS selector and an optional context (and handles various\n  // special cases).\n  // This method can be overridden in plugins.\n  zepto.init = function(selector, context) {\n    var dom\n    // If nothing given, return an empty Zepto collection\n    if (!selector) return zepto.Z()\n    // Optimize for string selectors\n    else if (typeof selector == 'string') {\n      selector = selector.trim()\n      // If it's a html fragment, create nodes from it\n      // Note: In both Chrome 21 and Firefox 15, DOM error 12\n      // is thrown if the fragment doesn't begin with <\n      if (selector[0] == '<' && fragmentRE.test(selector))\n        dom = zepto.fragment(selector, RegExp.$1, context), selector = null\n      // If there's a context, create a collection on that context first, and select\n      // nodes from there\n      else if (context !== undefined) return $(context).find(selector)\n      // If it's a CSS selector, use it to select nodes.\n      else dom = zepto.qsa(document, selector)\n    }\n    // If a function is given, call it when the DOM is ready\n    else if (isFunction(selector)) return $(document).ready(selector)\n    // If a Zepto collection is given, just return it\n    else if (zepto.isZ(selector)) return selector\n    else {\n      // normalize array if an array of nodes is given\n      if (isArray(selector)) dom = compact(selector)\n      // Wrap DOM nodes.\n      else if (isObject(selector))\n        dom = [selector], selector = null\n      // If it's a html fragment, create nodes from it\n      else if (fragmentRE.test(selector))\n        dom = zepto.fragment(selector.trim(), RegExp.$1, context), selector = null\n      // If there's a context, create a collection on that context first, and select\n      // nodes from there\n      else if (context !== undefined) return $(context).find(selector)\n      // And last but no least, if it's a CSS selector, use it to select nodes.\n      else dom = zepto.qsa(document, selector)\n    }\n    // create a new Zepto collection from the nodes found\n    return zepto.Z(dom, selector)\n  }\n\n  // `$` will be the base `Zepto` object. When calling this\n  // function just call `$.zepto.init, which makes the implementation\n  // details of selecting nodes and creating Zepto collections\n  // patchable in plugins.\n  $ = function(selector, context){\n    return zepto.init(selector, context)\n  }\n\n  function extend(target, source, deep) {\n    for (key in source)\n      if (deep && (isPlainObject(source[key]) || isArray(source[key]))) {\n        if (isPlainObject(source[key]) && !isPlainObject(target[key]))\n          target[key] = {}\n        if (isArray(source[key]) && !isArray(target[key]))\n          target[key] = []\n        extend(target[key], source[key], deep)\n      }\n      else if (source[key] !== undefined) target[key] = source[key]\n  }\n\n  // Copy all but undefined properties from one or more\n  // objects to the `target` object.\n  $.extend = function(target){\n    var deep, args = slice.call(arguments, 1)\n    if (typeof target == 'boolean') {\n      deep = target\n      target = args.shift()\n    }\n    args.forEach(function(arg){ extend(target, arg, deep) })\n    return target\n  }\n\n  // `$.zepto.qsa` is Zepto's CSS selector implementation which\n  // uses `document.querySelectorAll` and optimizes for some special cases, like `#id`.\n  // This method can be overridden in plugins.\n  zepto.qsa = function(element, selector){\n    var found,\n        maybeID = selector[0] == '#',\n        maybeClass = !maybeID && selector[0] == '.',\n        nameOnly = maybeID || maybeClass ? selector.slice(1) : selector, // Ensure that a 1 char tag name still gets checked\n        isSimple = simpleSelectorRE.test(nameOnly)\n    return (element.getElementById && isSimple && maybeID) ? // Safari DocumentFragment doesn't have getElementById\n      ( (found = element.getElementById(nameOnly)) ? [found] : [] ) :\n      (element.nodeType !== 1 && element.nodeType !== 9 && element.nodeType !== 11) ? [] :\n      slice.call(\n        isSimple && !maybeID && element.getElementsByClassName ? // DocumentFragment doesn't have getElementsByClassName/TagName\n          maybeClass ? element.getElementsByClassName(nameOnly) : // If it's simple, it could be a class\n          element.getElementsByTagName(selector) : // Or a tag\n          element.querySelectorAll(selector) // Or it's not simple, and we need to query all\n      )\n  }\n\n  function filtered(nodes, selector) {\n    return selector == null ? $(nodes) : $(nodes).filter(selector)\n  }\n\n  $.contains = document.documentElement.contains ?\n    function(parent, node) {\n      return parent !== node && parent.contains(node)\n    } :\n    function(parent, node) {\n      while (node && (node = node.parentNode))\n        if (node === parent) return true\n      return false\n    }\n\n  function funcArg(context, arg, idx, payload) {\n    return isFunction(arg) ? arg.call(context, idx, payload) : arg\n  }\n\n  function setAttribute(node, name, value) {\n    value == null ? node.removeAttribute(name) : node.setAttribute(name, value)\n  }\n\n  // access className property while respecting SVGAnimatedString\n  function className(node, value){\n    var klass = node.className || '',\n        svg   = klass && klass.baseVal !== undefined\n\n    if (value === undefined) return svg ? klass.baseVal : klass\n    svg ? (klass.baseVal = value) : (node.className = value)\n  }\n\n  // \"true\"  => true\n  // \"false\" => false\n  // \"null\"  => null\n  // \"42\"    => 42\n  // \"42.5\"  => 42.5\n  // \"08\"    => \"08\"\n  // JSON    => parse if valid\n  // String  => self\n  function deserializeValue(value) {\n    try {\n      return value ?\n        value == \"true\" ||\n        ( value == \"false\" ? false :\n          value == \"null\" ? null :\n          +value + \"\" == value ? +value :\n          /^[\\[\\{]/.test(value) ? $.parseJSON(value) :\n          value )\n        : value\n    } catch(e) {\n      return value\n    }\n  }\n\n  $.type = type\n  $.isFunction = isFunction\n  $.isWindow = isWindow\n  $.isArray = isArray\n  $.isPlainObject = isPlainObject\n\n  $.isEmptyObject = function(obj) {\n    var name\n    for (name in obj) return false\n    return true\n  }\n\n  $.isNumeric = function(val) {\n    var num = Number(val), type = typeof val\n    return val != null && type != 'boolean' &&\n      (type != 'string' || val.length) &&\n      !isNaN(num) && isFinite(num) || false\n  }\n\n  $.inArray = function(elem, array, i){\n    return emptyArray.indexOf.call(array, elem, i)\n  }\n\n  $.camelCase = camelize\n  $.trim = function(str) {\n    return str == null ? \"\" : String.prototype.trim.call(str)\n  }\n\n  // plugin compatibility\n  $.uuid = 0\n  $.support = { }\n  $.expr = { }\n  $.noop = function() {}\n\n  $.map = function(elements, callback){\n    var value, values = [], i, key\n    if (likeArray(elements))\n      for (i = 0; i < elements.length; i++) {\n        value = callback(elements[i], i)\n        if (value != null) values.push(value)\n      }\n    else\n      for (key in elements) {\n        value = callback(elements[key], key)\n        if (value != null) values.push(value)\n      }\n    return flatten(values)\n  }\n\n  $.each = function(elements, callback){\n    var i, key\n    if (likeArray(elements)) {\n      for (i = 0; i < elements.length; i++)\n        if (callback.call(elements[i], i, elements[i]) === false) return elements\n    } else {\n      for (key in elements)\n        if (callback.call(elements[key], key, elements[key]) === false) return elements\n    }\n\n    return elements\n  }\n\n  $.grep = function(elements, callback){\n    return filter.call(elements, callback)\n  }\n\n  if (window.JSON) $.parseJSON = JSON.parse\n\n  // Populate the class2type map\n  $.each(\"Boolean Number String Function Array Date RegExp Object Error\".split(\" \"), function(i, name) {\n    class2type[ \"[object \" + name + \"]\" ] = name.toLowerCase()\n  })\n\n  // Define methods that will be available on all\n  // Zepto collections\n  $.fn = {\n    constructor: zepto.Z,\n    length: 0,\n\n    // Because a collection acts like an array\n    // copy over these useful array functions.\n    forEach: emptyArray.forEach,\n    reduce: emptyArray.reduce,\n    push: emptyArray.push,\n    sort: emptyArray.sort,\n    splice: emptyArray.splice,\n    indexOf: emptyArray.indexOf,\n    concat: function(){\n      var i, value, args = []\n      for (i = 0; i < arguments.length; i++) {\n        value = arguments[i]\n        args[i] = zepto.isZ(value) ? value.toArray() : value\n      }\n      return concat.apply(zepto.isZ(this) ? this.toArray() : this, args)\n    },\n\n    // `map` and `slice` in the jQuery API work differently\n    // from their array counterparts\n    map: function(fn){\n      return $($.map(this, function(el, i){ return fn.call(el, i, el) }))\n    },\n    slice: function(){\n      return $(slice.apply(this, arguments))\n    },\n\n    ready: function(callback){\n      // need to check if document.body exists for IE as that browser reports\n      // document ready when it hasn't yet created the body element\n      if (readyRE.test(document.readyState) && document.body) callback($)\n      else document.addEventListener('DOMContentLoaded', function(){ callback($) }, false)\n      return this\n    },\n    get: function(idx){\n      return idx === undefined ? slice.call(this) : this[idx >= 0 ? idx : idx + this.length]\n    },\n    toArray: function(){ return this.get() },\n    size: function(){\n      return this.length\n    },\n    remove: function(){\n      return this.each(function(){\n        if (this.parentNode != null)\n          this.parentNode.removeChild(this)\n      })\n    },\n    each: function(callback){\n      emptyArray.every.call(this, function(el, idx){\n        return callback.call(el, idx, el) !== false\n      })\n      return this\n    },\n    filter: function(selector){\n      if (isFunction(selector)) return this.not(this.not(selector))\n      return $(filter.call(this, function(element){\n        return zepto.matches(element, selector)\n      }))\n    },\n    add: function(selector,context){\n      return $(uniq(this.concat($(selector,context))))\n    },\n    is: function(selector){\n      return this.length > 0 && zepto.matches(this[0], selector)\n    },\n    not: function(selector){\n      var nodes=[]\n      if (isFunction(selector) && selector.call !== undefined)\n        this.each(function(idx){\n          if (!selector.call(this,idx)) nodes.push(this)\n        })\n      else {\n        var excludes = typeof selector == 'string' ? this.filter(selector) :\n          (likeArray(selector) && isFunction(selector.item)) ? slice.call(selector) : $(selector)\n        this.forEach(function(el){\n          if (excludes.indexOf(el) < 0) nodes.push(el)\n        })\n      }\n      return $(nodes)\n    },\n    has: function(selector){\n      return this.filter(function(){\n        return isObject(selector) ?\n          $.contains(this, selector) :\n          $(this).find(selector).size()\n      })\n    },\n    eq: function(idx){\n      return idx === -1 ? this.slice(idx) : this.slice(idx, + idx + 1)\n    },\n    first: function(){\n      var el = this[0]\n      return el && !isObject(el) ? el : $(el)\n    },\n    last: function(){\n      var el = this[this.length - 1]\n      return el && !isObject(el) ? el : $(el)\n    },\n    find: function(selector){\n      var result, $this = this\n      if (!selector) result = $()\n      else if (typeof selector == 'object')\n        result = $(selector).filter(function(){\n          var node = this\n          return emptyArray.some.call($this, function(parent){\n            return $.contains(parent, node)\n          })\n        })\n      else if (this.length == 1) result = $(zepto.qsa(this[0], selector))\n      else result = this.map(function(){ return zepto.qsa(this, selector) })\n      return result\n    },\n    closest: function(selector, context){\n      var nodes = [], collection = typeof selector == 'object' && $(selector)\n      this.each(function(_, node){\n        while (node && !(collection ? collection.indexOf(node) >= 0 : zepto.matches(node, selector)))\n          node = node !== context && !isDocument(node) && node.parentNode\n        if (node && nodes.indexOf(node) < 0) nodes.push(node)\n      })\n      return $(nodes)\n    },\n    parents: function(selector){\n      var ancestors = [], nodes = this\n      while (nodes.length > 0)\n        nodes = $.map(nodes, function(node){\n          if ((node = node.parentNode) && !isDocument(node) && ancestors.indexOf(node) < 0) {\n            ancestors.push(node)\n            return node\n          }\n        })\n      return filtered(ancestors, selector)\n    },\n    parent: function(selector){\n      return filtered(uniq(this.pluck('parentNode')), selector)\n    },\n    children: function(selector){\n      return filtered(this.map(function(){ return children(this) }), selector)\n    },\n    contents: function() {\n      return this.map(function() { return this.contentDocument || slice.call(this.childNodes) })\n    },\n    siblings: function(selector){\n      return filtered(this.map(function(i, el){\n        return filter.call(children(el.parentNode), function(child){ return child!==el })\n      }), selector)\n    },\n    empty: function(){\n      return this.each(function(){ this.innerHTML = '' })\n    },\n    // `pluck` is borrowed from Prototype.js\n    pluck: function(property){\n      return $.map(this, function(el){ return el[property] })\n    },\n    show: function(){\n      return this.each(function(){\n        this.style.display == \"none\" && (this.style.display = '')\n        if (getComputedStyle(this, '').getPropertyValue(\"display\") == \"none\")\n          this.style.display = defaultDisplay(this.nodeName)\n      })\n    },\n    replaceWith: function(newContent){\n      return this.before(newContent).remove()\n    },\n    wrap: function(structure){\n      var func = isFunction(structure)\n      if (this[0] && !func)\n        var dom   = $(structure).get(0),\n            clone = dom.parentNode || this.length > 1\n\n      return this.each(function(index){\n        $(this).wrapAll(\n          func ? structure.call(this, index) :\n            clone ? dom.cloneNode(true) : dom\n        )\n      })\n    },\n    wrapAll: function(structure){\n      if (this[0]) {\n        $(this[0]).before(structure = $(structure))\n        var children\n        // drill down to the inmost element\n        while ((children = structure.children()).length) structure = children.first()\n        $(structure).append(this)\n      }\n      return this\n    },\n    wrapInner: function(structure){\n      var func = isFunction(structure)\n      return this.each(function(index){\n        var self = $(this), contents = self.contents(),\n            dom  = func ? structure.call(this, index) : structure\n        contents.length ? contents.wrapAll(dom) : self.append(dom)\n      })\n    },\n    unwrap: function(){\n      this.parent().each(function(){\n        $(this).replaceWith($(this).children())\n      })\n      return this\n    },\n    clone: function(){\n      return this.map(function(){ return this.cloneNode(true) })\n    },\n    hide: function(){\n      return this.css(\"display\", \"none\")\n    },\n    toggle: function(setting){\n      return this.each(function(){\n        var el = $(this)\n        ;(setting === undefined ? el.css(\"display\") == \"none\" : setting) ? el.show() : el.hide()\n      })\n    },\n    prev: function(selector){ return $(this.pluck('previousElementSibling')).filter(selector || '*') },\n    next: function(selector){ return $(this.pluck('nextElementSibling')).filter(selector || '*') },\n    html: function(html){\n      return 0 in arguments ?\n        this.each(function(idx){\n          var originHtml = this.innerHTML\n          $(this).empty().append( funcArg(this, html, idx, originHtml) )\n        }) :\n        (0 in this ? this[0].innerHTML : null)\n    },\n    text: function(text){\n      return 0 in arguments ?\n        this.each(function(idx){\n          var newText = funcArg(this, text, idx, this.textContent)\n          this.textContent = newText == null ? '' : ''+newText\n        }) :\n        (0 in this ? this.pluck('textContent').join(\"\") : null)\n    },\n    attr: function(name, value){\n      var result\n      return (typeof name == 'string' && !(1 in arguments)) ?\n        (0 in this && this[0].nodeType == 1 && (result = this[0].getAttribute(name)) != null ? result : undefined) :\n        this.each(function(idx){\n          if (this.nodeType !== 1) return\n          if (isObject(name)) for (key in name) setAttribute(this, key, name[key])\n          else setAttribute(this, name, funcArg(this, value, idx, this.getAttribute(name)))\n        })\n    },\n    removeAttr: function(name){\n      return this.each(function(){ this.nodeType === 1 && name.split(' ').forEach(function(attribute){\n        setAttribute(this, attribute)\n      }, this)})\n    },\n    prop: function(name, value){\n      name = propMap[name] || name\n      return (1 in arguments) ?\n        this.each(function(idx){\n          this[name] = funcArg(this, value, idx, this[name])\n        }) :\n        (this[0] && this[0][name])\n    },\n    removeProp: function(name){\n      name = propMap[name] || name\n      return this.each(function(){ delete this[name] })\n    },\n    data: function(name, value){\n      var attrName = 'data-' + name.replace(capitalRE, '-$1').toLowerCase()\n\n      var data = (1 in arguments) ?\n        this.attr(attrName, value) :\n        this.attr(attrName)\n\n      return data !== null ? deserializeValue(data) : undefined\n    },\n    val: function(value){\n      if (0 in arguments) {\n        if (value == null) value = \"\"\n        return this.each(function(idx){\n          this.value = funcArg(this, value, idx, this.value)\n        })\n      } else {\n        return this[0] && (this[0].multiple ?\n           $(this[0]).find('option').filter(function(){ return this.selected }).pluck('value') :\n           this[0].value)\n      }\n    },\n    offset: function(coordinates){\n      if (coordinates) return this.each(function(index){\n        var $this = $(this),\n            coords = funcArg(this, coordinates, index, $this.offset()),\n            parentOffset = $this.offsetParent().offset(),\n            props = {\n              top:  coords.top  - parentOffset.top,\n              left: coords.left - parentOffset.left\n            }\n\n        if ($this.css('position') == 'static') props['position'] = 'relative'\n        $this.css(props)\n      })\n      if (!this.length) return null\n      if (document.documentElement !== this[0] && !$.contains(document.documentElement, this[0]))\n        return {top: 0, left: 0}\n      var obj = this[0].getBoundingClientRect()\n      return {\n        left: obj.left + window.pageXOffset,\n        top: obj.top + window.pageYOffset,\n        width: Math.round(obj.width),\n        height: Math.round(obj.height)\n      }\n    },\n    css: function(property, value){\n      if (arguments.length < 2) {\n        var element = this[0]\n        if (typeof property == 'string') {\n          if (!element) return\n          return element.style[camelize(property)] || getComputedStyle(element, '').getPropertyValue(property)\n        } else if (isArray(property)) {\n          if (!element) return\n          var props = {}\n          var computedStyle = getComputedStyle(element, '')\n          $.each(property, function(_, prop){\n            props[prop] = (element.style[camelize(prop)] || computedStyle.getPropertyValue(prop))\n          })\n          return props\n        }\n      }\n\n      var css = ''\n      if (type(property) == 'string') {\n        if (!value && value !== 0)\n          this.each(function(){ this.style.removeProperty(dasherize(property)) })\n        else\n          css = dasherize(property) + \":\" + maybeAddPx(property, value)\n      } else {\n        for (key in property)\n          if (!property[key] && property[key] !== 0)\n            this.each(function(){ this.style.removeProperty(dasherize(key)) })\n          else\n            css += dasherize(key) + ':' + maybeAddPx(key, property[key]) + ';'\n      }\n\n      return this.each(function(){ this.style.cssText += ';' + css })\n    },\n    index: function(element){\n      return element ? this.indexOf($(element)[0]) : this.parent().children().indexOf(this[0])\n    },\n    hasClass: function(name){\n      if (!name) return false\n      return emptyArray.some.call(this, function(el){\n        return this.test(className(el))\n      }, classRE(name))\n    },\n    addClass: function(name){\n      if (!name) return this\n      return this.each(function(idx){\n        if (!('className' in this)) return\n        classList = []\n        var cls = className(this), newName = funcArg(this, name, idx, cls)\n        newName.split(/\\s+/g).forEach(function(klass){\n          if (!$(this).hasClass(klass)) classList.push(klass)\n        }, this)\n        classList.length && className(this, cls + (cls ? \" \" : \"\") + classList.join(\" \"))\n      })\n    },\n    removeClass: function(name){\n      return this.each(function(idx){\n        if (!('className' in this)) return\n        if (name === undefined) return className(this, '')\n        classList = className(this)\n        funcArg(this, name, idx, classList).split(/\\s+/g).forEach(function(klass){\n          classList = classList.replace(classRE(klass), \" \")\n        })\n        className(this, classList.trim())\n      })\n    },\n    toggleClass: function(name, when){\n      if (!name) return this\n      return this.each(function(idx){\n        var $this = $(this), names = funcArg(this, name, idx, className(this))\n        names.split(/\\s+/g).forEach(function(klass){\n          (when === undefined ? !$this.hasClass(klass) : when) ?\n            $this.addClass(klass) : $this.removeClass(klass)\n        })\n      })\n    },\n    scrollTop: function(value){\n      if (!this.length) return\n      var hasScrollTop = 'scrollTop' in this[0]\n      if (value === undefined) return hasScrollTop ? this[0].scrollTop : this[0].pageYOffset\n      return this.each(hasScrollTop ?\n        function(){ this.scrollTop = value } :\n        function(){ this.scrollTo(this.scrollX, value) })\n    },\n    scrollLeft: function(value){\n      if (!this.length) return\n      var hasScrollLeft = 'scrollLeft' in this[0]\n      if (value === undefined) return hasScrollLeft ? this[0].scrollLeft : this[0].pageXOffset\n      return this.each(hasScrollLeft ?\n        function(){ this.scrollLeft = value } :\n        function(){ this.scrollTo(value, this.scrollY) })\n    },\n    position: function() {\n      if (!this.length) return\n\n      var elem = this[0],\n        // Get *real* offsetParent\n        offsetParent = this.offsetParent(),\n        // Get correct offsets\n        offset       = this.offset(),\n        parentOffset = rootNodeRE.test(offsetParent[0].nodeName) ? { top: 0, left: 0 } : offsetParent.offset()\n\n      // Subtract element margins\n      // note: when an element has margin: auto the offsetLeft and marginLeft\n      // are the same in Safari causing offset.left to incorrectly be 0\n      offset.top  -= parseFloat( $(elem).css('margin-top') ) || 0\n      offset.left -= parseFloat( $(elem).css('margin-left') ) || 0\n\n      // Add offsetParent borders\n      parentOffset.top  += parseFloat( $(offsetParent[0]).css('border-top-width') ) || 0\n      parentOffset.left += parseFloat( $(offsetParent[0]).css('border-left-width') ) || 0\n\n      // Subtract the two offsets\n      return {\n        top:  offset.top  - parentOffset.top,\n        left: offset.left - parentOffset.left\n      }\n    },\n    offsetParent: function() {\n      return this.map(function(){\n        var parent = this.offsetParent || document.body\n        while (parent && !rootNodeRE.test(parent.nodeName) && $(parent).css(\"position\") == \"static\")\n          parent = parent.offsetParent\n        return parent\n      })\n    }\n  }\n\n  // for now\n  $.fn.detach = $.fn.remove\n\n  // Generate the `width` and `height` functions\n  ;['width', 'height'].forEach(function(dimension){\n    var dimensionProperty =\n      dimension.replace(/./, function(m){ return m[0].toUpperCase() })\n\n    $.fn[dimension] = function(value){\n      var offset, el = this[0]\n      if (value === undefined) return isWindow(el) ? el['inner' + dimensionProperty] :\n        isDocument(el) ? el.documentElement['scroll' + dimensionProperty] :\n        (offset = this.offset()) && offset[dimension]\n      else return this.each(function(idx){\n        el = $(this)\n        el.css(dimension, funcArg(this, value, idx, el[dimension]()))\n      })\n    }\n  })\n\n  function traverseNode(node, fun) {\n    fun(node)\n    for (var i = 0, len = node.childNodes.length; i < len; i++)\n      traverseNode(node.childNodes[i], fun)\n  }\n\n  // Generate the `after`, `prepend`, `before`, `append`,\n  // `insertAfter`, `insertBefore`, `appendTo`, and `prependTo` methods.\n  adjacencyOperators.forEach(function(operator, operatorIndex) {\n    var inside = operatorIndex % 2 //=> prepend, append\n\n    $.fn[operator] = function(){\n      // arguments can be nodes, arrays of nodes, Zepto objects and HTML strings\n      var argType, nodes = $.map(arguments, function(arg) {\n            var arr = []\n            argType = type(arg)\n            if (argType == \"array\") {\n              arg.forEach(function(el) {\n                if (el.nodeType !== undefined) return arr.push(el)\n                else if ($.zepto.isZ(el)) return arr = arr.concat(el.get())\n                arr = arr.concat(zepto.fragment(el))\n              })\n              return arr\n            }\n            return argType == \"object\" || arg == null ?\n              arg : zepto.fragment(arg)\n          }),\n          parent, copyByClone = this.length > 1\n      if (nodes.length < 1) return this\n\n      return this.each(function(_, target){\n        parent = inside ? target : target.parentNode\n\n        // convert all methods to a \"before\" operation\n        target = operatorIndex == 0 ? target.nextSibling :\n                 operatorIndex == 1 ? target.firstChild :\n                 operatorIndex == 2 ? target :\n                 null\n\n        var parentInDocument = $.contains(document.documentElement, parent)\n\n        nodes.forEach(function(node){\n          if (copyByClone) node = node.cloneNode(true)\n          else if (!parent) return $(node).remove()\n\n          parent.insertBefore(node, target)\n          if (parentInDocument) traverseNode(node, function(el){\n            if (el.nodeName != null && el.nodeName.toUpperCase() === 'SCRIPT' &&\n               (!el.type || el.type === 'text/javascript') && !el.src){\n              var target = el.ownerDocument ? el.ownerDocument.defaultView : window\n              target['eval'].call(target, el.innerHTML)\n            }\n          })\n        })\n      })\n    }\n\n    // after    => insertAfter\n    // prepend  => prependTo\n    // before   => insertBefore\n    // append   => appendTo\n    $.fn[inside ? operator+'To' : 'insert'+(operatorIndex ? 'Before' : 'After')] = function(html){\n      $(html)[operator](this)\n      return this\n    }\n  })\n\n  zepto.Z.prototype = Z.prototype = $.fn\n\n  // Export internal API functions in the `$.zepto` namespace\n  zepto.uniq = uniq\n  zepto.deserializeValue = deserializeValue\n  $.zepto = zepto\n\n  return $\n})();\n/**\n * origin code\n * */\n;(function($){\n  var _zid = 1, undefined,\n      slice = Array.prototype.slice,\n      isFunction = $.isFunction,\n      isString = function(obj){ return typeof obj == 'string' },\n      handlers = {},\n      specialEvents={},\n      focusinSupported = 'onfocusin' in window,\n      focus = { focus: 'focusin', blur: 'focusout' },\n      hover = { mouseenter: 'mouseover', mouseleave: 'mouseout' }\n\n  specialEvents.click = specialEvents.mousedown = specialEvents.mouseup = specialEvents.mousemove = 'MouseEvents'\n\n  function zid(element) {\n    return element._zid || (element._zid = _zid++)\n  }\n  function findHandlers(element, event, fn, selector) {\n    event = parse(event)\n    if (event.ns) var matcher = matcherFor(event.ns)\n    return (handlers[zid(element)] || []).filter(function(handler) {\n      return handler\n        && (!event.e  || handler.e == event.e)\n        && (!event.ns || matcher.test(handler.ns))\n        && (!fn       || zid(handler.fn) === zid(fn))\n        && (!selector || handler.sel == selector)\n    })\n  }\n  function parse(event) {\n    var parts = ('' + event).split('.')\n    return {e: parts[0], ns: parts.slice(1).sort().join(' ')}\n  }\n  function matcherFor(ns) {\n    return new RegExp('(?:^| )' + ns.replace(' ', ' .* ?') + '(?: |$)')\n  }\n\n  function eventCapture(handler, captureSetting) {\n    return handler.del &&\n      (!focusinSupported && (handler.e in focus)) ||\n      !!captureSetting\n  }\n\n  function realEvent(type) {\n    return hover[type] || (focusinSupported && focus[type]) || type\n  }\n\n  function add(element, events, fn, data, selector, delegator, capture){\n    var id = zid(element), set = (handlers[id] || (handlers[id] = []))\n    events.split(/\\s/).forEach(function(event){\n      if (event == 'ready') return $(document).ready(fn)\n      var handler   = parse(event)\n      handler.fn    = fn\n      handler.sel   = selector\n      // emulate mouseenter, mouseleave\n      if (handler.e in hover) fn = function(e){\n        var related = e.relatedTarget\n        if (!related || (related !== this && !$.contains(this, related)))\n          return handler.fn.apply(this, arguments)\n      }\n      handler.del   = delegator\n      var callback  = delegator || fn\n      handler.proxy = function(e){\n        e = compatible(e)\n        if (e.isImmediatePropagationStopped()) return\n        e.data = data\n        var result = callback.apply(element, e._args == undefined ? [e] : [e].concat(e._args))\n        if (result === false) e.preventDefault(), e.stopPropagation()\n        return result\n      }\n      handler.i = set.length\n      set.push(handler)\n      if ('addEventListener' in element)\n        element.addEventListener(realEvent(handler.e), handler.proxy, eventCapture(handler, capture))\n    })\n  }\n  function remove(element, events, fn, selector, capture){\n    var id = zid(element)\n    ;(events || '').split(/\\s/).forEach(function(event){\n      findHandlers(element, event, fn, selector).forEach(function(handler){\n        delete handlers[id][handler.i]\n      if ('removeEventListener' in element)\n        element.removeEventListener(realEvent(handler.e), handler.proxy, eventCapture(handler, capture))\n      })\n    })\n  }\n\n  $.event = { add: add, remove: remove }\n\n  $.proxy = function(fn, context) {\n    var args = (2 in arguments) && slice.call(arguments, 2)\n    if (isFunction(fn)) {\n      var proxyFn = function(){ return fn.apply(context, args ? args.concat(slice.call(arguments)) : arguments) }\n      proxyFn._zid = zid(fn)\n      return proxyFn\n    } else if (isString(context)) {\n      if (args) {\n        args.unshift(fn[context], fn)\n        return $.proxy.apply(null, args)\n      } else {\n        return $.proxy(fn[context], fn)\n      }\n    } else {\n      throw new TypeError(\"expected function\")\n    }\n  }\n\n  $.fn.bind = function(event, data, callback){\n    return this.on(event, data, callback)\n  }\n  $.fn.unbind = function(event, callback){\n    return this.off(event, callback)\n  }\n  $.fn.one = function(event, selector, data, callback){\n    return this.on(event, selector, data, callback, 1)\n  }\n\n  var returnTrue = function(){return true},\n      returnFalse = function(){return false},\n      ignoreProperties = /^([A-Z]|returnValue$|layer[XY]$|webkitMovement[XY]$)/,\n      eventMethods = {\n        preventDefault: 'isDefaultPrevented',\n        stopImmediatePropagation: 'isImmediatePropagationStopped',\n        stopPropagation: 'isPropagationStopped'\n      }\n\n  function compatible(event, source) {\n    if (source || !event.isDefaultPrevented) {\n      source || (source = event)\n\n      $.each(eventMethods, function(name, predicate) {\n        var sourceMethod = source[name]\n        event[name] = function(){\n          this[predicate] = returnTrue\n          return sourceMethod && sourceMethod.apply(source, arguments)\n        }\n        event[predicate] = returnFalse\n      })\n\n      event.timeStamp || (event.timeStamp = Date.now())\n\n      if (source.defaultPrevented !== undefined ? source.defaultPrevented :\n          'returnValue' in source ? source.returnValue === false :\n          source.getPreventDefault && source.getPreventDefault())\n        event.isDefaultPrevented = returnTrue\n    }\n    return event\n  }\n\n  function createProxy(event) {\n    var key, proxy = { originalEvent: event }\n    for (key in event)\n      if (!ignoreProperties.test(key) && event[key] !== undefined) proxy[key] = event[key]\n\n    return compatible(proxy, event)\n  }\n\n  $.fn.delegate = function(selector, event, callback){\n    return this.on(event, selector, callback)\n  }\n  $.fn.undelegate = function(selector, event, callback){\n    return this.off(event, selector, callback)\n  }\n\n  $.fn.live = function(event, callback){\n    $(document.body).delegate(this.selector, event, callback)\n    return this\n  }\n  $.fn.die = function(event, callback){\n    $(document.body).undelegate(this.selector, event, callback)\n    return this\n  }\n\n  $.fn.on = function(event, selector, data, callback, one){\n    var autoRemove, delegator, $this = this\n    if (event && !isString(event)) {\n      $.each(event, function(type, fn){\n        $this.on(type, selector, data, fn, one)\n      })\n      return $this\n    }\n\n    if (!isString(selector) && !isFunction(callback) && callback !== false)\n      callback = data, data = selector, selector = undefined\n    if (callback === undefined || data === false)\n      callback = data, data = undefined\n\n    if (callback === false) callback = returnFalse\n\n    return $this.each(function(_, element){\n      if (one) autoRemove = function(e){\n        remove(element, e.type, callback)\n        return callback.apply(this, arguments)\n      }\n\n      if (selector) delegator = function(e){\n        var evt, match = $(e.target).closest(selector, element).get(0)\n        if (match && match !== element) {\n          evt = $.extend(createProxy(e), {currentTarget: match, liveFired: element})\n          return (autoRemove || callback).apply(match, [evt].concat(slice.call(arguments, 1)))\n        }\n      }\n\n      add(element, event, callback, data, selector, delegator || autoRemove)\n    })\n  }\n  $.fn.off = function(event, selector, callback){\n    var $this = this\n    if (event && !isString(event)) {\n      $.each(event, function(type, fn){\n        $this.off(type, selector, fn)\n      })\n      return $this\n    }\n\n    if (!isString(selector) && !isFunction(callback) && callback !== false)\n      callback = selector, selector = undefined\n\n    if (callback === false) callback = returnFalse\n\n    return $this.each(function(){\n      remove(this, event, callback, selector)\n    })\n  }\n\n  $.fn.trigger = function(event, args){\n    event = (isString(event) || $.isPlainObject(event)) ? $.Event(event) : compatible(event)\n    event._args = args\n    return this.each(function(){\n      // handle focus(), blur() by calling them directly\n      if (event.type in focus && typeof this[event.type] == \"function\") this[event.type]()\n      // items in the collection might not be DOM elements\n      else if ('dispatchEvent' in this) this.dispatchEvent(event)\n      else $(this).triggerHandler(event, args)\n    })\n  }\n\n  // triggers event handlers on current element just as if an event occurred,\n  // doesn't trigger an actual event, doesn't bubble\n  $.fn.triggerHandler = function(event, args){\n    var e, result\n    this.each(function(i, element){\n      e = createProxy(isString(event) ? $.Event(event) : event)\n      e._args = args\n      e.target = element\n      $.each(findHandlers(element, event.type || event), function(i, handler){\n        result = handler.proxy(e)\n        if (e.isImmediatePropagationStopped()) return false\n      })\n    })\n    return result\n  }\n\n  // shortcut methods for `.bind(event, fn)` for each event type\n  ;('focusin focusout focus blur load resize scroll unload click dblclick '+\n  'mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave '+\n  'change select keydown keypress keyup error').split(' ').forEach(function(event) {\n    $.fn[event] = function(callback) {\n      return (0 in arguments) ?\n        this.bind(event, callback) :\n        this.trigger(event)\n    }\n  })\n\n  $.Event = function(type, props) {\n    if (!isString(type)) props = type, type = props.type\n    var event = document.createEvent(specialEvents[type] || 'Events'), bubbles = true\n    if (props) for (var name in props) (name == 'bubbles') ? (bubbles = !!props[name]) : (event[name] = props[name])\n    event.initEvent(type, bubbles, true)\n    return compatible(event)\n  }\n\n})(Zepto)\n\n;(function($){\n  var jsonpID = +new Date(),\n      document = window.document,\n      key,\n      name,\n      rscript = /<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi,\n      scriptTypeRE = /^(?:text|application)\\/javascript/i,\n      xmlTypeRE = /^(?:text|application)\\/xml/i,\n      jsonType = 'application/json',\n      htmlType = 'text/html',\n      blankRE = /^\\s*$/,\n      originAnchor = document.createElement('a')\n\n  originAnchor.href = window.location.href\n\n  // trigger a custom event and return false if it was cancelled\n  function triggerAndReturn(context, eventName, data) {\n    var event = $.Event(eventName)\n    $(context).trigger(event, data)\n    return !event.isDefaultPrevented()\n  }\n\n  // trigger an Ajax \"global\" event\n  function triggerGlobal(settings, context, eventName, data) {\n    if (settings.global) return triggerAndReturn(context || document, eventName, data)\n  }\n\n  // Number of active Ajax requests\n  $.active = 0\n\n  function ajaxStart(settings) {\n    if (settings.global && $.active++ === 0) triggerGlobal(settings, null, 'ajaxStart')\n  }\n  function ajaxStop(settings) {\n    if (settings.global && !(--$.active)) triggerGlobal(settings, null, 'ajaxStop')\n  }\n\n  // triggers an extra global event \"ajaxBeforeSend\" that's like \"ajaxSend\" but cancelable\n  function ajaxBeforeSend(xhr, settings) {\n    var context = settings.context\n    if (settings.beforeSend.call(context, xhr, settings) === false ||\n        triggerGlobal(settings, context, 'ajaxBeforeSend', [xhr, settings]) === false)\n      return false\n\n    triggerGlobal(settings, context, 'ajaxSend', [xhr, settings])\n  }\n  function ajaxSuccess(data, xhr, settings, deferred) {\n    var context = settings.context, status = 'success'\n    settings.success.call(context, data, status, xhr)\n    if (deferred) deferred.resolveWith(context, [data, status, xhr])\n    triggerGlobal(settings, context, 'ajaxSuccess', [xhr, settings, data])\n    ajaxComplete(status, xhr, settings)\n  }\n  // type: \"timeout\", \"error\", \"abort\", \"parsererror\"\n  function ajaxError(error, type, xhr, settings, deferred) {\n    var context = settings.context\n    settings.error.call(context, xhr, type, error)\n    if (deferred) deferred.rejectWith(context, [xhr, type, error])\n    triggerGlobal(settings, context, 'ajaxError', [xhr, settings, error || type])\n    ajaxComplete(type, xhr, settings)\n  }\n  // status: \"success\", \"notmodified\", \"error\", \"timeout\", \"abort\", \"parsererror\"\n  function ajaxComplete(status, xhr, settings) {\n    var context = settings.context\n    settings.complete.call(context, xhr, status)\n    triggerGlobal(settings, context, 'ajaxComplete', [xhr, settings])\n    ajaxStop(settings)\n  }\n\n  function ajaxDataFilter(data, type, settings) {\n    if (settings.dataFilter == empty) return data\n    var context = settings.context\n    return settings.dataFilter.call(context, data, type)\n  }\n\n  // Empty function, used as default callback\n  function empty() {}\n\n  $.ajaxJSONP = function(options, deferred){\n    if (!('type' in options)) return $.ajax(options)\n\n    var _callbackName = options.jsonpCallback,\n      callbackName = ($.isFunction(_callbackName) ?\n        _callbackName() : _callbackName) || ('Zepto' + (jsonpID++)),\n      script = document.createElement('script'),\n      originalCallback = window[callbackName],\n      responseData,\n      abort = function(errorType) {\n        $(script).triggerHandler('error', errorType || 'abort')\n      },\n      xhr = { abort: abort }, abortTimeout\n\n    if (deferred) deferred.promise(xhr)\n\n    $(script).on('load error', function(e, errorType){\n      clearTimeout(abortTimeout)\n      $(script).off().remove()\n\n      if (e.type == 'error' || !responseData) {\n        ajaxError(null, errorType || 'error', xhr, options, deferred)\n      } else {\n        ajaxSuccess(responseData[0], xhr, options, deferred)\n      }\n\n      window[callbackName] = originalCallback\n      if (responseData && $.isFunction(originalCallback))\n        originalCallback(responseData[0])\n\n      originalCallback = responseData = undefined\n    })\n\n    if (ajaxBeforeSend(xhr, options) === false) {\n      abort('abort')\n      return xhr\n    }\n\n    window[callbackName] = function(){\n      responseData = arguments\n    }\n\n    script.src = options.url.replace(/\\?(.+)=\\?/, '?$1=' + callbackName)\n    document.head.appendChild(script)\n\n    if (options.timeout > 0) abortTimeout = setTimeout(function(){\n      abort('timeout')\n    }, options.timeout)\n\n    return xhr\n  }\n\n  $.ajaxSettings = {\n    // Default type of request\n    type: 'GET',\n    // Callback that is executed before request\n    beforeSend: empty,\n    // Callback that is executed if the request succeeds\n    success: empty,\n    // Callback that is executed the the server drops error\n    error: empty,\n    // Callback that is executed on request complete (both: error and success)\n    complete: empty,\n    // The context for the callbacks\n    context: null,\n    // Whether to trigger \"global\" Ajax events\n    global: true,\n    // Transport\n    xhr: function () {\n      return new window.XMLHttpRequest()\n    },\n    // MIME types mapping\n    // IIS returns Javascript as \"application/x-javascript\"\n    accepts: {\n      script: 'text/javascript, application/javascript, application/x-javascript',\n      json:   jsonType,\n      xml:    'application/xml, text/xml',\n      html:   htmlType,\n      text:   'text/plain'\n    },\n    // Whether the request is to another domain\n    crossDomain: false,\n    // Default timeout\n    timeout: 0,\n    // Whether data should be serialized to string\n    processData: true,\n    // Whether the browser should be allowed to cache GET responses\n    cache: true,\n    //Used to handle the raw response data of XMLHttpRequest.\n    //This is a pre-filtering function to sanitize the response.\n    //The sanitized response should be returned\n    dataFilter: empty\n  }\n\n  function mimeToDataType(mime) {\n    if (mime) mime = mime.split(';', 2)[0]\n    return mime && ( mime == htmlType ? 'html' :\n      mime == jsonType ? 'json' :\n      scriptTypeRE.test(mime) ? 'script' :\n      xmlTypeRE.test(mime) && 'xml' ) || 'text'\n  }\n\n  function appendQuery(url, query) {\n    if (query == '') return url\n    return (url + '&' + query).replace(/[&?]{1,2}/, '?')\n  }\n\n  // serialize payload and append it to the URL for GET requests\n  function serializeData(options) {\n    if (options.processData && options.data && $.type(options.data) != \"string\")\n      options.data = $.param(options.data, options.traditional)\n    if (options.data && (!options.type || options.type.toUpperCase() == 'GET' || 'jsonp' == options.dataType))\n      options.url = appendQuery(options.url, options.data), options.data = undefined\n  }\n\n  $.ajax = function(options){\n    var settings = $.extend({}, options || {}),\n        deferred = $.Deferred && $.Deferred(),\n        urlAnchor, hashIndex\n    for (key in $.ajaxSettings) if (settings[key] === undefined) settings[key] = $.ajaxSettings[key]\n\n    ajaxStart(settings)\n\n    if (!settings.crossDomain) {\n      urlAnchor = document.createElement('a')\n      urlAnchor.href = settings.url\n      // cleans up URL for .href (IE only), see https://github.com/madrobby/zepto/pull/1049\n      urlAnchor.href = urlAnchor.href\n      settings.crossDomain = (originAnchor.protocol + '//' + originAnchor.host) !== (urlAnchor.protocol + '//' + urlAnchor.host)\n    }\n\n    if (!settings.url) settings.url = window.location.toString()\n    if ((hashIndex = settings.url.indexOf('#')) > -1) settings.url = settings.url.slice(0, hashIndex)\n    serializeData(settings)\n\n    var dataType = settings.dataType, hasPlaceholder = /\\?.+=\\?/.test(settings.url)\n    if (hasPlaceholder) dataType = 'jsonp'\n\n    if (settings.cache === false || (\n         (!options || options.cache !== true) &&\n         ('script' == dataType || 'jsonp' == dataType)\n        ))\n      settings.url = appendQuery(settings.url, '_=' + Date.now())\n\n    if ('jsonp' == dataType) {\n      if (!hasPlaceholder)\n        settings.url = appendQuery(settings.url,\n          settings.jsonp ? (settings.jsonp + '=?') : settings.jsonp === false ? '' : 'callback=?')\n      return $.ajaxJSONP(settings, deferred)\n    }\n\n    var mime = settings.accepts[dataType],\n        headers = { },\n        setHeader = function(name, value) { headers[name.toLowerCase()] = [name, value] },\n        protocol = /^([\\w-]+:)\\/\\//.test(settings.url) ? RegExp.$1 : window.location.protocol,\n        xhr = settings.xhr(),\n        nativeSetHeader = xhr.setRequestHeader,\n        abortTimeout\n\n    if (deferred) deferred.promise(xhr)\n\n    if (!settings.crossDomain) setHeader('X-Requested-With', 'XMLHttpRequest')\n    setHeader('Accept', mime || '*/*')\n    if (mime = settings.mimeType || mime) {\n      if (mime.indexOf(',') > -1) mime = mime.split(',', 2)[0]\n      xhr.overrideMimeType && xhr.overrideMimeType(mime)\n    }\n    if (settings.contentType || (settings.contentType !== false && settings.data && settings.type.toUpperCase() != 'GET'))\n      setHeader('Content-Type', settings.contentType || 'application/x-www-form-urlencoded')\n\n    if (settings.headers) for (name in settings.headers) setHeader(name, settings.headers[name])\n    xhr.setRequestHeader = setHeader\n\n    xhr.onreadystatechange = function(){\n      if (xhr.readyState == 4) {\n        xhr.onreadystatechange = empty\n        clearTimeout(abortTimeout)\n        var result, error = false\n        if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304 || (xhr.status == 0 && protocol == 'file:')) {\n          dataType = dataType || mimeToDataType(settings.mimeType || xhr.getResponseHeader('content-type'))\n\n          if (xhr.responseType == 'arraybuffer' || xhr.responseType == 'blob')\n            result = xhr.response\n          else {\n            result = xhr.responseText\n\n            try {\n              // http://perfectionkills.com/global-eval-what-are-the-options/\n              // sanitize response accordingly if data filter callback provided\n              result = ajaxDataFilter(result, dataType, settings)\n              if (dataType == 'script')    (1,eval)(result)\n              else if (dataType == 'xml')  result = xhr.responseXML\n              else if (dataType == 'json') result = blankRE.test(result) ? null : $.parseJSON(result)\n            } catch (e) { error = e }\n\n            if (error) return ajaxError(error, 'parsererror', xhr, settings, deferred)\n          }\n\n          ajaxSuccess(result, xhr, settings, deferred)\n        } else {\n          ajaxError(xhr.statusText || null, xhr.status ? 'error' : 'abort', xhr, settings, deferred)\n        }\n      }\n    }\n\n    if (ajaxBeforeSend(xhr, settings) === false) {\n      xhr.abort()\n      ajaxError(null, 'abort', xhr, settings, deferred)\n      return xhr\n    }\n\n    var async = 'async' in settings ? settings.async : true\n    xhr.open(settings.type, settings.url, async, settings.username, settings.password)\n\n    if (settings.xhrFields) for (name in settings.xhrFields) xhr[name] = settings.xhrFields[name]\n\n    for (name in headers) nativeSetHeader.apply(xhr, headers[name])\n\n    if (settings.timeout > 0) abortTimeout = setTimeout(function(){\n        xhr.onreadystatechange = empty\n        xhr.abort()\n        ajaxError(null, 'timeout', xhr, settings, deferred)\n      }, settings.timeout)\n\n    // avoid sending empty string (#319)\n    xhr.send(settings.data ? settings.data : null)\n    return xhr\n  }\n\n  // handle optional data/success arguments\n  function parseArguments(url, data, success, dataType) {\n    if ($.isFunction(data)) dataType = success, success = data, data = undefined\n    if (!$.isFunction(success)) dataType = success, success = undefined\n    return {\n      url: url\n    , data: data\n    , success: success\n    , dataType: dataType\n    }\n  }\n\n  $.get = function(/* url, data, success, dataType */){\n    return $.ajax(parseArguments.apply(null, arguments))\n  }\n\n  $.post = function(/* url, data, success, dataType */){\n    var options = parseArguments.apply(null, arguments)\n    options.type = 'POST'\n    return $.ajax(options)\n  }\n\n  $.getJSON = function(/* url, data, success */){\n    var options = parseArguments.apply(null, arguments)\n    options.dataType = 'json'\n    return $.ajax(options)\n  }\n\n  $.fn.load = function(url, data, success){\n    if (!this.length) return this\n    var self = this, parts = url.split(/\\s/), selector,\n        options = parseArguments(url, data, success),\n        callback = options.success\n    if (parts.length > 1) options.url = parts[0], selector = parts[1]\n    options.success = function(response){\n      self.html(selector ?\n        $('<div>').html(response.replace(rscript, \"\")).find(selector)\n        : response)\n      callback && callback.apply(self, arguments)\n    }\n    $.ajax(options)\n    return this\n  }\n\n  var escape = encodeURIComponent\n\n  function serialize(params, obj, traditional, scope){\n    var type, array = $.isArray(obj), hash = $.isPlainObject(obj)\n    $.each(obj, function(key, value) {\n      type = $.type(value)\n      if (scope) key = traditional ? scope :\n        scope + '[' + (hash || type == 'object' || type == 'array' ? key : '') + ']'\n      // handle data in serializeArray() format\n      if (!scope && array) params.add(value.name, value.value)\n      // recurse into nested objects\n      else if (type == \"array\" || (!traditional && type == \"object\"))\n        serialize(params, value, traditional, key)\n      else params.add(key, value)\n    })\n  }\n\n  $.param = function(obj, traditional){\n    var params = []\n    params.add = function(key, value) {\n      if ($.isFunction(value)) value = value()\n      if (value == null) value = \"\"\n      this.push(escape(key) + '=' + escape(value))\n    }\n    serialize(params, obj, traditional)\n    return params.join('&').replace(/%20/g, '+')\n  }\n})(Zepto)\n\n;(function($){\n  $.fn.serializeArray = function() {\n    var name, type, result = [],\n      add = function(value) {\n        if (value.forEach) return value.forEach(add)\n        result.push({ name: name, value: value })\n      }\n    if (this[0]) $.each(this[0].elements, function(_, field){\n      type = field.type, name = field.name\n      if (name && field.nodeName.toLowerCase() != 'fieldset' &&\n        !field.disabled && type != 'submit' && type != 'reset' && type != 'button' && type != 'file' &&\n        ((type != 'radio' && type != 'checkbox') || field.checked))\n          add($(field).val())\n    })\n    return result\n  }\n\n  $.fn.serialize = function(){\n    var result = []\n    this.serializeArray().forEach(function(elm){\n      result.push(encodeURIComponent(elm.name) + '=' + encodeURIComponent(elm.value))\n    })\n    return result.join('&')\n  }\n\n  $.fn.submit = function(callback) {\n    if (0 in arguments) this.bind('submit', callback)\n    else if (this.length) {\n      var event = $.Event('submit')\n      this.eq(0).trigger(event)\n      if (!event.isDefaultPrevented()) this.get(0).submit()\n    }\n    return this\n  }\n\n})(Zepto)\n\n;(function(){\n  // getComputedStyle shouldn't freak out when called\n  // without a valid element as argument\n  try {\n    getComputedStyle(undefined)\n  } catch(e) {\n    var nativeGetComputedStyle = getComputedStyle\n    window.getComputedStyle = function(element, pseudoElement){\n      try {\n        return nativeGetComputedStyle(element, pseudoElement)\n      } catch(e) {\n        return null\n      }\n    }\n  }\n})();\n\n/**\n * Deferred code\n * */\nvar rnotwhite = (/\\S+/g);\n\n\n\n// String to Object options format cache\nvar optionsCache = {};\nvar _typeof = function(arg){\n    return Object.prototype.toString.call(arg);\n};\nvar isDate = function(arg){\n    return _typeof(arg) === '[object Date]';\n};\nvar isArray = function(arg){\n    return _typeof(arg) === '[object Array]';\n};\n\nvar isRegExp = function(arg){\n    return _typeof(arg) === '[object RegExp]';\n};\n\nvar isObject = function(arg){\n    return _typeof(arg) === '[object Object]';\n};\n\nvar isFunction = function(arg){\n    return _typeof(arg) === '[object Function]';\n};\n\n// Convert String-formatted options into Object-formatted ones and store in cache\nfunction createOptions( options ) {\n    var object = optionsCache[ options ] = {};\n    Zepto.each( options.match( rnotwhite ) || [], function( _, flag ) {\n        object[ flag ] = true;\n    });\n    return object;\n}\n\n/*\n * Create a callback list using the following parameters:\n *\n *\toptions: an optional list of space-separated options that will change how\n *\t\t\tthe callback list behaves or a more traditional option object\n *\n * By default a callback list will act like an event callback list and can be\n * \"fired\" multiple times.\n *\n * Possible options:\n *\n *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n *\n *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n *\t\t\t\t\tvalues (like a Deferred)\n *\n *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n *\n *\tstopOnFalse:\tinterrupt callings when a callback returns false\n *\n */\nZepto.Callbacks = function( options ) {\n\n    // Convert options from String-formatted to Object-formatted if needed\n    // (we check in cache first)\n    options = typeof options === \"string\" ?\n        ( optionsCache[ options ] || createOptions( options ) ) :\n        Zepto.extend( {}, options );\n\n    var // Flag to know if list is currently firing\n        firing,\n        // Last fire value (for non-forgettable lists)\n        memory,\n        // Flag to know if list was already fired\n        fired,\n        // End of the loop when firing\n        firingLength,\n        // Index of currently firing callback (modified by remove if needed)\n        firingIndex,\n        // First callback to fire (used internally by add and fireWith)\n        firingStart,\n        // Actual callback list\n        list = [],\n        // Stack of fire calls for repeatable lists\n        stack = !options.once && [],\n        // Fire callbacks\n        fire = function( data ) {\n            memory = options.memory && data;\n            fired = true;\n            firingIndex = firingStart || 0;\n            firingStart = 0;\n            firingLength = list.length;\n            firing = true;\n            for ( ; list && firingIndex < firingLength; firingIndex++ ) {\n                if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {\n                    memory = false; // To prevent further calls using add\n                    break;\n                }\n            }\n            firing = false;\n            if ( list ) {\n                if ( stack ) {\n                    if ( stack.length ) {\n                        fire( stack.shift() );\n                    }\n                } else if ( memory ) {\n                    list = [];\n                } else {\n                    self.disable();\n                }\n            }\n        },\n        // Actual Callbacks object\n        self = {\n            // Add a callback or a collection of callbacks to the list\n            add: function() {\n                if ( list ) {\n                    // First, we save the current length\n                    var start = list.length;\n                    (function add( args ) {\n                        Zepto.each( args, function( _, arg ) {\n                            var type = Zepto.type( arg );\n                            if ( type === \"function\" ) {\n                                if ( !options.unique || !self.has( arg ) ) {\n                                    list.push( arg );\n                                }\n                            } else if ( arg && arg.length && type !== \"string\" ) {\n                                // Inspect recursively\n                                add( arg );\n                            }\n                        });\n                    })( arguments );\n                    // Do we need to add the callbacks to the\n                    // current firing batch?\n                    if ( firing ) {\n                        firingLength = list.length;\n                        // With memory, if we're not firing then\n                        // we should call right away\n                    } else if ( memory ) {\n                        firingStart = start;\n                        fire( memory );\n                    }\n                }\n                return this;\n            },\n            // Remove a callback from the list\n            remove: function() {\n                if ( list ) {\n                    Zepto.each( arguments, function( _, arg ) {\n                        var index;\n                        while ( ( index = Zepto.inArray( arg, list, index ) ) > -1 ) {\n                            list.splice( index, 1 );\n                            // Handle firing indexes\n                            if ( firing ) {\n                                if ( index <= firingLength ) {\n                                    firingLength--;\n                                }\n                                if ( index <= firingIndex ) {\n                                    firingIndex--;\n                                }\n                            }\n                        }\n                    });\n                }\n                return this;\n            },\n            // Check if a given callback is in the list.\n            // If no argument is given, return whether or not list has callbacks attached.\n            has: function( fn ) {\n                return fn ? Zepto.inArray( fn, list ) > -1 : !!( list && list.length );\n            },\n            // Remove all callbacks from the list\n            empty: function() {\n                list = [];\n                firingLength = 0;\n                return this;\n            },\n            // Have the list do nothing anymore\n            disable: function() {\n                list = stack = memory = undefined;\n                return this;\n            },\n            // Is it disabled?\n            disabled: function() {\n                return !list;\n            },\n            // Lock the list in its current state\n            lock: function() {\n                stack = undefined;\n                if ( !memory ) {\n                    self.disable();\n                }\n                return this;\n            },\n            // Is it locked?\n            locked: function() {\n                return !stack;\n            },\n            // Call all callbacks with the given context and arguments\n            fireWith: function( context, args ) {\n                if ( list && ( !fired || stack ) ) {\n                    args = args || [];\n                    args = [ context, args.slice ? args.slice() : args ];\n                    if ( firing ) {\n                        stack.push( args );\n                    } else {\n                        fire( args );\n                    }\n                }\n                return this;\n            },\n            // Call all the callbacks with the given arguments\n            fire: function() {\n                self.fireWith( this, arguments );\n                return this;\n            },\n            // To know if the callbacks have already been called at least once\n            fired: function() {\n                return !!fired;\n            }\n        };\n\n    return self;\n};\n\n\nZepto.extend(Zepto,{\n\n    Deferred: function( func ) {\n        var tuples = [\n                // action, add listener, listener list, final state\n                [ \"resolve\", \"done\", Zepto.Callbacks(\"once memory\"), \"resolved\" ],\n                [ \"reject\", \"fail\", Zepto.Callbacks(\"once memory\"), \"rejected\" ],\n                [ \"notify\", \"progress\", Zepto.Callbacks(\"memory\") ]\n            ],\n            state = \"pending\",\n            promise = {\n                state: function() {\n                    return state;\n                },\n                always: function() {\n                    deferred.done( arguments ).fail( arguments );\n                    return this;\n                },\n                then: function( /* fnDone, fnFail, fnProgress */ ) {\n                    var fns = arguments;\n                    return Zepto.Deferred(function( newDefer ) {\n                        Zepto.each( tuples, function( i, tuple ) {\n                            var fn = Zepto.isFunction( fns[ i ] ) && fns[ i ];\n                            // deferred[ done | fail | progress ] for forwarding actions to newDefer\n                            deferred[ tuple[1] ](function() {\n                                var returned = fn && fn.apply( this, arguments );\n                                if ( returned && Zepto.isFunction( returned.promise ) ) {\n                                    returned.promise()\n                                        .done( newDefer.resolve )\n                                        .fail( newDefer.reject )\n                                        .progress( newDefer.notify );\n                                } else {\n                                    newDefer[ tuple[ 0 ] + \"With\" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );\n                                }\n                            });\n                        });\n                        fns = null;\n                    }).promise();\n                },\n                // Get a promise for this deferred\n                // If obj is provided, the promise aspect is added to the object\n                promise: function( obj ) {\n                    return obj != null ? Zepto.extend( obj, promise ) : promise;\n                }\n            },\n            deferred = {};\n\n        // Keep pipe for back-compat\n        promise.pipe = promise.then;\n\n        // Add list-specific methods\n        Zepto.each( tuples, function( i, tuple ) {\n            var list = tuple[ 2 ],\n                stateString = tuple[ 3 ];\n\n            // promise[ done | fail | progress ] = list.add\n            promise[ tuple[1] ] = list.add;\n\n            // Handle state\n            if ( stateString ) {\n                list.add(function() {\n                    // state = [ resolved | rejected ]\n                    state = stateString;\n\n                    // [ reject_list | resolve_list ].disable; progress_list.lock\n                }, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );\n            }\n\n            // deferred[ resolve | reject | notify ]\n            deferred[ tuple[0] ] = function() {\n                deferred[ tuple[0] + \"With\" ]( this === deferred ? promise : this, arguments );\n                return this;\n            };\n            deferred[ tuple[0] + \"With\" ] = list.fireWith;\n        });\n\n        // Make the deferred a promise\n        promise.promise( deferred );\n\n        // Call given func if any\n        if ( func ) {\n            func.call( deferred, deferred );\n        }\n\n        // All done!\n        return deferred;\n    },\n    isObject: isObject,\n    // Deferred helper\n    when: function( subordinate /* , ..., subordinateN */ ) {\n        var i = 0,\n            resolveValues = slice.call( arguments ),\n            length = resolveValues.length,\n\n            // the count of uncompleted subordinates\n            remaining = length !== 1 || ( subordinate && Zepto.isFunction( subordinate.promise ) ) ? length : 0,\n\n            // the master Deferred. If resolveValues consist of only a single Deferred, just use that.\n            deferred = remaining === 1 ? subordinate : Zepto.Deferred(),\n\n            // Update function for both resolve and progress values\n            updateFunc = function( i, contexts, values ) {\n                return function( value ) {\n                    contexts[ i ] = this;\n                    values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;\n                    if ( values === progressValues ) {\n                        deferred.notifyWith( contexts, values );\n\n                    } else if ( !(--remaining) ) {\n                        deferred.resolveWith( contexts, values );\n                    }\n                };\n            },\n\n            progressValues, progressContexts, resolveContexts;\n\n        // add listeners to Deferred subordinates; treat others as resolved\n        if ( length > 1 ) {\n            progressValues = new Array( length );\n            progressContexts = new Array( length );\n            resolveContexts = new Array( length );\n            for ( ; i < length; i++ ) {\n                if ( resolveValues[ i ] && Zepto.isFunction( resolveValues[ i ].promise ) ) {\n                    resolveValues[ i ].promise()\n                        .done( updateFunc( i, resolveContexts, resolveValues ) )\n                        .fail( deferred.reject )\n                        .progress( updateFunc( i, progressContexts, progressValues ) );\n                } else {\n                    --remaining;\n                }\n            }\n        }\n\n        // if we're not waiting on anything, resolve the master\n        if ( !remaining ) {\n            deferred.resolveWith( resolveContexts, resolveValues );\n        }\n\n        return deferred.promise();\n    }\n});\n\nZepto.copy = function(source, destination, stackSource, stackDest) {\n\n    if (!destination) {\n        destination = source;\n        if (source) {\n            if (isArray(source)) {\n                destination = copy(source, [], stackSource, stackDest);\n            } else if (isDate(source)) {\n                destination = new Date(source.getTime());\n            } else if (isRegExp(source)) {\n                destination = new RegExp(source.source,source.toString().match(/[^\\/]*$/)[0]);\n                destination.lastIndex = source.lastIndex;\n            } else if (isObject(source)) {\n                var emptyObject = Object.create(Object.getPrototypeOf(source));\n                destination = copy(source, emptyObject, stackSource, stackDest);\n            }\n        }\n    } else {\n        if (source === destination)\n            throw new Error(\"Can't copy! Source and destination are identical.\");\n        stackSource = stackSource || [];\n        stackDest = stackDest || [];\n        if (isObject(source)) {\n            var index = stackSource.indexOf(source);\n            if (index !== -1)\n                return stackDest[index];\n            stackSource.push(source);\n            stackDest.push(destination);\n        }\n        var result;\n        if (isArray(source)) {\n            destination.length = 0;\n            for (var i = 0; i < source.length; i++) {\n                result = copy(source[i], null , stackSource, stackDest);\n                if (isObject(source[i])) {\n                    stackSource.push(source[i]);\n                    stackDest.push(result);\n                }\n                destination.push(result);\n            }\n        } else {\n            if (isArray(destination)) {\n                destination.length = 0;\n            } else {\n                for(var key in destination){\n                    delete destination[key];\n                }\n            }\n            for (var key in source) {\n                if (source.hasOwnProperty(key)) {\n                    result = copy(source[key], null , stackSource, stackDest);\n                    if (isObject(source[key])) {\n                        stackSource.push(source[key]);\n                        stackDest.push(result);\n                    }\n                    destination[key] = result;\n                }\n            }\n        }\n    }\n    return destination;\n}\nmodule.exports = Zepto;\n\n\n//# sourceURL=webpack://zzjzAppLib/./src/module/zepto.js?");

/***/ })

/******/ });
});